(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Node::usage="Node[i,{info},{Node[j,\[Ellipsis]],Node[k,\[Ellipsis]]}] denotes a node in a branching tree.  This node is labelled by the integer i; information on it is given by {info}.  The node has descendant nodes labelled j, k.  A terminal node (a leaf) is denoted by Node[i,{info},{}].";


(* ::Input::Initialization:: *)
NodeFunction::usage="NodeFunction is an option for CollapseGenealogy and MakeGenealogy which can be set to extract information about each node.";


(* ::Input::Initialization:: *)
ExtractGenealogy::usage="ExtractGenealogy[g,i] gives the genealogy that descends from node i.  For an ancestral graph, ExtractGenealogy[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},x] generates the genealogy corresponding to map position x. InformationFunction->f generates an information list f[i,x]. ExtractGenealogy[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] generates the set of genealogies, applying to segments demarcated by Junctions[g].  All parts of the genome must have a single common ancestor.";


(* ::Input::Initialization:: *)
DeleteGenealogy::usage="DeleteGenealogy[g,i] deletes the genealogy that descends from node i.";


(* ::Input::Initialization:: *)
AddGenealogy::usage="AddGenealogy[\!\(\*SubscriptBox[\(g\), \(1\)]\),\!\(\*SubscriptBox[\(g\), \(2\)]\),i,j,info] adds genealogy \!\(\*SubscriptBox[\(g\), \(2\)]\) to genealogy \!\(\*SubscriptBox[\(g\), \(1\)]\), immediately above existing node i of \!\(\*SubscriptBox[\(g\), \(1\)]\).  The new node is labelled j.  The new node is labelled j, and carries information info.  If i=j, then \!\(\*SubscriptBox[\(g\), \(2\)]\) is added to existing node i, and its information is unaltered.  Node i must be found once and only once within \!\(\*SubscriptBox[\(g\), \(1\)]\).";


(* ::Input::Initialization:: *)
AddNode::usage="AddNode[g,i,k,info] adds a new node k immediately above existing node i of g.  The new node carries information info.  AddNode[g,i,j,k,info] adds a new node k between nodes i and j of an unrooted genealogy.";


(* ::Input::Initialization:: *)
CondenseGenealogy::usage="CondenseGenealogy[g] removes all nodes that have only one descendant. However, the root node is not affected. ";


(* ::Input::Initialization:: *)
Nodes::usage="Nodes[g] lists all the nodes of the genealogy g, including the leaves. ";


(* ::Input::Initialization:: *)
InternalNodes::usage="InternalNodes[g] lists the internal nodes of the genealogy g. ";


(* ::Input::Initialization:: *)
Leaves::usage="Leaves[g] lists the terminal nodes of the genealogy g. For an ancestral graph, Leaves[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] gives those lineages which start at times when no other lineages end";


(* ::Input::Initialization:: *)
 CollapseGenealogy::usage="CollapseGenealogy[genealogy] reduces the genealogy to a nested list.  Node\[Rule]False only lists the leaves. NodeFunction\[Rule]f extracts a nested list of the information associated with each node, by applying f[i,{info}] to the full set of information contained in the genealogy. Nested\[Rule]False does not preserve the nested structure.";


(* ::Input::Initialization:: *)
SizeOfGenealogyPlot::usage="SizeOfGenealogyPlot[g] gives the minimum and maximum coordinates, held as the last element of the information lists in g, in the form {{\!\(\*SubscriptBox[\(x\), \(min\)]\),\!\(\*SubscriptBox[\(y\), \(min\)]\)},{\!\(\*SubscriptBox[\(x\), \(max\)]\),\!\(\*SubscriptBox[\(y\), \(max\)]\)}}.";


(* ::Input::Initialization:: *)
MakeGenealogyPlot::usage="MakeGenealogyPlot[g] appends coordinates to the information lists; these are used by PlotGenealogy[].  The vertical coordinate is incremented in units of 1, and the vertical span equals the number of lineages, minus 1. ";


(* ::Input::Initialization:: *)
PlotGenealogy::usage="PlotGenealogy[g] plots a genealogy.  PlotGenealogy[g,NodeFunction\[Rule]f] uses f[i,info] to derive the coordinates; this might represent coalescence time, for example.  By default, nodes & leaves are labelled.  NodeLabels\[Rule]None suppresses the labelling; NodeLabels\[Rule]f uses f[i,info] to derive labels.  MakeGenealogyPlot\[Rule]False requires that  the coordinates are held as the last element of the information list.  By default, these are generated by MakeGenealogyPlot[g].";


(* ::Input::Initialization:: *)
LeafOffset::usage="LeafOffset is an option for PlotGenealogy which determines the position of leaf labels.";


(* ::Input::Initialization:: *)
NodeOffset::usage="NodeOffset is an option for PlotGenealogy which determines the position of node labels.";


(* ::Input::Initialization:: *)
LeafLabels::usage="LeafLabels\[Rule]f is an option for PlotGenealogy which uses f[i,info] to construct labels for the leaves; LeafLabels\[Rule]None suppresses labels.";


(* ::Input::Initialization:: *)
MostRecentCommonAncestor::usage="MostRecentCommonAncestor[g,i,j] gives the most recent common ancestor of nodes i, j.  ";


(* ::Input::Initialization:: *)
Nested::usage="Nested is an option for CollapseGenealogy which determines whether the nested structure is preserved. ";


(* ::Input::Initialization:: *)
ExtractInformation::usage="ExtractInformation[g,i] gives the information associated with node i. ExtractInformation[g] gives a list of the information for all the nodes.  For an ancestral graph, ExtractInformation[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},l] extracts the information associated with the lineage labelled by l.  Checks that there is only one such lineage. ExtractInformation[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},{\!\(\*SubscriptBox[\(l\), \(1\)]\),\[Ellipsis]}] extracts a list of such information. ";


(* ::Input::Initialization:: *)
TransformInformation::usage="TransformInformation[g,f] replaces the information list info by f[node,info].";


(* ::Input::Initialization:: *)
ListToGenealogy::usage="ListToGenealogy[list] constructs a genealogy from a nested list of the form {label,{\!\(\*SubscriptBox[\(node\), \(1\)]\),\!\(\*SubscriptBox[\(node\), \(2\)]\),\[Ellipsis]}}.  Information on each node can be included using NodeFunction\[Rule]f, where f[label] gives a list of information for the node with that label.  ListToGenealogy[{{a,b},{c,d}},Node\[Rule]False] gives a genealogy relating objects {a,b,\[Ellipsis]}.  Internal nodes are unlabelled.";


(* ::Input::Initialization:: *)
OrderedNodes::usage="OrderedNodes[g,f] gives a list of the nodes in the genealogy, in the order defined by f[ i,{info}].  OrderedNodes[g,f,Node\[Rule]True] only lists internal nodes.";


(* ::Input::Initialization:: *)
Ancestors::usage="Ancestors[g,node] lists the ancestors of the node.  For an ancestral graph, Ancestors[{AncestralLineage[\[Ellipsis]],\[Ellipsis]},l] lists the immediate ancestors of lineage l.  MapPosition\[Rule]x restricts the list to ancestors at map position x.  AncestorList\[Rule]All gives a list of all ancestors, in  the form {\!\(\*SubscriptBox[\(l\), \(1\)]\),{{\!\(\*SubscriptBox[\(d\), \(1\)]\),{\[Ellipsis]}},{\!\(\*SubscriptBox[\(d\), \(2\)]\),{\[Ellipsis]}}}}.  AncestorList\[Rule]Roots gives only the root ancestors.  ";


(* ::Input::Initialization:: *)
Descendants::usage="Descendants[g,node] lists the immediate descendants of the node.  Descendants[g,node,DescendantList\[Rule]All] lists all the descendants of the node. Descendants[g,node,DescendantList\[Rule]Leaves] lists only the descendant leaves of the node.  For an ancestral graph, Descendants[{AncestralLineage[\[Ellipsis]],\[Ellipsis]},l] lists the immediate descendants from lineage l.  MapPosition\[Rule]x restricts the list to descendants at map position x.  DescendantList\[Rule]All gives a list of all descendants, in  the form {\!\(\*SubscriptBox[\(l\), \(1\)]\),{{\!\(\*SubscriptBox[\(d\), \(1\)]\),{\[Ellipsis]}},{\!\(\*SubscriptBox[\(d\), \(2\)]\),{\[Ellipsis]}}}}. DescendantList\[Rule]Leaves gives only the descendant leaves.";


(* ::Input::Initialization:: *)
DescendantList::usage="DescendantList is an option for Descendants[]; may be set to Next, All or Leaves.";


(* ::Input::Initialization:: *)
UnrootedGenealogy::usage="UnrootedGenealogy[g] gives an unrooted genealogy.";


(* ::Input::Initialization:: *)
RootedGenealogy::usage="\!\(\*FormBox[\(RootedGenealogy\),
TextForm]\)[g,i] roots an unrooted genealogy at node i";


(* ::Input::Initialization:: *)
SiblingList::usage="SiblingList[g] lists all pairs of leaves which are directly related.";


(* ::Input::Initialization:: *)
GenealogyToFamily::usage="GenealogyToFamily[g,f] gives a list of the family structures following successive coalescences. The function f[i,{info}] gives the ordering of the coalescence for node i.";


(* ::Input::Initialization:: *)
FamilyToGenealogy::usage="FamilyToGenealogy[{a,b,c,\[Ellipsis]},S] gives a randomly constructed genealogy which satistfies the sequence of family structures S, and which relates {a,b,c,\[Ellipsis]}.  The terminal nodes are labelled by {a,b,c,\[Ellipsis]}, and the internal nodes are labelled by integers giving the order of the coalescence events. NodeLabels\[Rule]{\!\(\*SubscriptBox[\(label\), \(1\)]\),\[Ellipsis]} allows an arbitrary list of labels for the internal nodes.  NodeInformation\[Rule]{\!\(\*SubscriptBox[\(info\), \(1\)]\),\[Ellipsis]}, LeafInformation\[Rule]{\!\(\*SubscriptBox[\(info\), \(a\)]\),\[Ellipsis]} allow arbitrary lists of information to be associated with the nodes and leaves.  With n items, there are n nodes, and so all the optional lists must have length n.";


(* ::Input::Initialization:: *)
 LeafInformation::usage="LeafInformation\[Rule]{\!\(\*SubscriptBox[\(info\), \(a\)]\),\[Ellipsis]} is an option for FamilyToGenealogy[] which specifies information associated with each leaf.";


(* ::Input::Initialization:: *)
 NodeInformation::usage="NodeInformation\[Rule]{\!\(\*SubscriptBox[\(info\), \(1\)]\),\[Ellipsis]} is an option for FamilyToGenealogy[] which specifies information associated with each internal node.  The number of such nodes is the same as the number of leaves; nodes are ordered by their timing.";


(* ::Input::Initialization:: *)
 NodeLabels::usage="NodeLabels\[Rule]{\!\(\*SubscriptBox[\(label\), \(1\)]\),\[Ellipsis]} is an option for FamilyToGenealogy[] which specifies labels for each internal node.  The number of such nodes is the same as the number of leaves; nodes are ordered by their timing.  NodeLabels\[Rule]f is an option for PlotGenealogy which uses f[i,info] to construct labels for the nodes; NodeLabels\[Rule]None suppresses labels.";


(* ::Input::Initialization:: *)
GenealogyB::usage="GenealogyB[j,i,k] is the coefficient of Exp[-\!\(\*SubscriptBox[\(\[Lambda]\), \(i\)]\)t/2N] in the expression for \!\(\*SubscriptBox[\(P\), \(j\)]\), the probability of j coalescences having occurred.";


(* ::Input::Initialization:: *)
CoalescenceDistribution::usage="CoalescenceDistribution[j,k,t] is the probability of j coalescences having occurred among k lineages over t generations (scaled to 2N) ";


(* ::Input::Initialization:: *)
SimplifyFamilies::usage="SimplifyFamilies replaces duplications such as {{3,1},{2,2},{1,2}} by {{3,1},{3,2}}";


(* ::Input::Initialization:: *)
FamilyProbability::usage="FamilyProbability[S] gives the probability that the family structure S would be produced, given a certain number of coalescence events.";


(* ::Input::Initialization:: *)
NumberOfLineages::usage="NumberOfLineages[g]  gives the total number of lineages (i.e., terminal nodes) involved in the genealogy g. NumberOfLineages[g,i] gives the number that descend from node i.  NumberOfLineages[S] can also be applied to a list of family sizes, S";


(* ::Input::Initialization:: *)
PairwiseIdentity::usage="PairwiseIdentity[S] gives the mean pairwise identity, given the family structure S.";


(* ::Input::Initialization:: *)
AllSets::usage="AllSets[j,k] lists all the family structures that could yield j families and k genes";


(* ::Input::Initialization:: *)
NewS::usage="NewS[S] gives a recursion for the family structures";


(* ::Input::Initialization:: *)
NumberOfFamilies::usage="NumberOfFamilies[S] gives the number of families";


(* ::Input::Initialization:: *)
CoalescenceTimes::usage="CoalescenceTimes is an option for RandomGenealogy.  CoalescenceTimes\[Rule]Random uses RandomCoalescenceTimes[k]; otherwise a list of times must be supplied";


(* ::Input::Initialization:: *)
RandomCoalescenceTimes::usage="RandomCoalescenceTimes[k] gives a list of random coalescence times, scaled to 2N generations. RandomCoalescenceTimes[n,k,R] generates a sequence of n coalescences and recombinations, starting with k lineages at t=0. The output is a list of n items of the form {t,k,j}, where t is the time of the event;k is the number of lineages after the event; and j is the location of the recombination event in the interval {0,R}. j=None indicates a coalescence.  RandomCoalescenceTimes[k,R] generates a single item, with rate k(k-1)/2 of coalescence and k R of recombination.";


(* ::Input::Initialization:: *)
RandomCoalescenceTimesG::usage="RandomCoalescenceTimesG[k,\[Lambda]] gives a list of random coalescence times, scaled to 2N generations, for a population growing at rate \[Lambda] to current (scaled) size 1. This simply uses a scale transformation t=log[1+\[Lambda]t]/\[Lambda], which reduces the coalescence times deeper in the tree. Note that if \[Lambda]<0 (a shrinking population) then lineages that do not coalesce by rescaled time 1/|\[Lambda]| will never coalesce: coalescence times are then given as \[Infinity].  ";


(* ::Input::Initialization:: *)
NumberOfCoalescences::usage="NumberOfCoalescences[k,T] gives a randomly sampled number of coalescence events that occur in T (scaled to 2N). NumberOfCoalescences[{t1,t2..},T] does the same, for a list of coalescence times. ";


(* ::Input::Initialization:: *)
TotalLength::usage="TotalLength[{t1,t2,..}] is the total length of the tree, given the coalescence times.";


(* ::Input::Initialization:: *)
RandomFamilies::usage="RandomFamilies[k] generates a list of the family sizes going back through time to the common ancestor of k genes.";


(* ::Input::Initialization:: *)
RandomPreviousFamily::usage="RandomPreviousFamily[{1,1,2,3}] generates a random coalescence to give the previous family structure";


(* ::Input::Initialization:: *)
RandomGenealogy::usage="RandomGenealogy[{\!\(\*SubscriptBox[\(leaf\), \(1\)]\),\!\(\*SubscriptBox[\(leaf\), \(2\)]\),\[Ellipsis]}] gives a random realisation of the coalescent process.  Terminal nodes are labelled {\!\(\*SubscriptBox[\(leaf\), \(1\)]\),\!\(\*SubscriptBox[\(leaf\), \(2\)]\),\[Ellipsis]}, and internal nodes are labelled by an integer, in the order in which they occur.  Each node carries its time, scaled to 2N generations.  MutationRate\[Rule]\[Theta] simulates infinite-sites mutation at a rate \[Theta]=4N\[Mu]; mutations are labelled by unique integers. NodeLabels\[Rule]{\!\(\*SubscriptBox[\(label\), \(1\)]\),\[Ellipsis]} can be used to label internal nodes.   RandomGenealogy[{\!\(\*SubscriptBox[\(leaf\), \(1\)]\),\!\(\*SubscriptBox[\(leaf\), \(2\)]\)\[Ellipsis]},n,R] gives a random realisation of the coalescent process with recombination; there are n events. RandomGenealogy[{\!\(\*SubscriptBox[\(leaf\), \(1\)]\),\!\(\*SubscriptBox[\(leaf\), \(2\)]\)\[Ellipsis]},{{\!\(\*SubscriptBox[\(t\), \(1\)]\),\!\(\*SubscriptBox[\(k\), \(1\)]\),\!\(\*SubscriptBox[\(x\), \(1\)]\)}\[Ellipsis]},R] gives a random realisation for a specific sequence of events, generated by RandomCoalescenceTimes[n,k,R]; this preserves null lineages, however.  DeleteNullLineages->True ignores null events; can only be used with the first form. PrintDetails\[Rule]True prints details of the construction.  MaxTime->t stops after time t.  Fixation->True stops when the whole genome is fixed.";


(* ::Input::Initialization:: *)
MutationRate::usage="MutationRate\[Rule]\[Theta] is an option for RandomGenealogy[] which sets the scaled mutation rate \[Theta]=4N\[VeryThinSpace]\[Mu].  Default is MutationRate\[Rule]None.";


(* ::Input::Initialization:: *)
DeletedMutations::usage="DeletedMutations[g,{\!\(\*SubscriptBox[\(T\), \(0\)]\),\!\(\*SubscriptBox[\(T\), \(1\)]\)}] lists those mutations that should be deleted because they occurred in time interval {\!\(\*SubscriptBox[\(T\), \(0\)]\),\!\(\*SubscriptBox[\(T\), \(1\)]\)}.  This list may be to some extent randomly generated. ";


(* ::Input::Initialization:: *)
RandomBottleneckedGenealogy::usage="RandomBottleneckedGenealogy[leaves,{T0,T1},\[Theta]] gives a random genealogy, with no mutations occurring in time interval {T0,T1}.";


(* ::Input::Initialization:: *)
MomentGeneratingFunction::usage="MomentGeneratingFunction[g,\[Omega],\[Theta]] gives the generating function for the number of mutations along each branch of the genealogy, under the infinite sites model. MomentGeneratingFunction[{{a},{b},\[Ellipsis]},\[Omega],\[Theta]] gives the generating function for all tree topologies, in terms of variables \[Omega][S] which correspond to those mutations in branches ancestral to the set of leaves S. Stores results. ";


(* ::Input::Initialization:: *)
IncidenceMatrix::usage=IncidenceMatrix::usage<>"  For genealogies, IncidenceMatrix[g,nodelist] gives the matrix describing an ordering of coalescences defined by nodelist.  The last member of nodelist is the root node.  The elements of the matrix show whether a branch is present during the time for which there are 1\[LessEqual]i\[LessEqual]n lineages. Rows correspond to branches, in the order specified by nodelist. ";


(* ::Input::Initialization:: *)
MonteCarloProbability::usage="MonteCarloProbability[g,nodelist,J,\[Theta],\!\(\*SuperscriptBox[\(\[Theta]\), \(*\)]\),ns] makes a Monte Carlo estimate of the probability of the genealogy g and the mutational configuration J, assuming that the coalescences are in the order specified by nodelist. A list of ns values is returned. MonteCarloProbability[g,J,\[Theta],\!\(\*SuperscriptBox[\(\[Theta]\), \(*\)]\),ns] makes no assumptions as to the order of events. Uses the arbitrary parameter \!\(\*SuperscriptBox[\(\[Theta]\), \(*\)]\) to make random partitions.  \!\(\*SuperscriptBox[\(\[Theta]\), \(*\)]\) must be a number, but \[Theta] can be symbolic.";


(* ::Input::Initialization:: *)
PossibleCoalescenceOrder::usage="PossibleCoalescenceOrder[g] lists the possible orders in which coalescence events might occur; each is given by an ordered list of nodes.  Leaves are listed first, and the root node last.";


(* ::Input::Initialization:: *)
RandomCoalescenceOrder::usage="RandomCoalescenceOrder[g] gives a random ordering of the possible coalescence events";


(* ::Input::Initialization:: *)
NumberOfPossibleCoalescences::usage="NumberOfPossibleCoalescences[g,nodelist] gives the number of possible coalescences that could occur at each step. Only internal nodes are included. The order of coalescences is defined by nodelist";


(* ::Input::Initialization:: *)
NumberOfMutations::usage="NumberOfMutations[g,node] gives the number of mutations that occurred on the branch leading down to the specified node. The set of mutations is given in the second element of the information for each node. ";


(* ::Input::Initialization:: *)
Mutations::usage="Mutations[g] gives the set of mutations that occured on g.  Mutations[g,i] gives the mutations that arose on the branch leading down to node i.  By default, these are held in the second element of the information list.  NodeFunction\[Rule]f uses f[i,info] to extract the mutation list.";


(* ::Input::Initialization:: *)
MutationOrigin::usage="MutationOrigin[g,k] gives the first node at which mutation k appears.   By default, the mutations are held in the second element of the information list, and the coalescence time as the first element.  NodeFunction\[Rule]f uses f[i,info] to return {time,mutations}.";


(* ::Input::Initialization:: *)
MutationInterval::usage="MutationInterval[g,k] gives the time interval in which mutation k arose.  By default, the mutations are held in the second element of the information list, and the coalescence time as the first element.  NodeFunction\[Rule]f uses f[i,info] to return {time,mutations}.";


(* ::Input::Initialization:: *)
ExactProbability::usage="ExactProbability[g,\[Theta]] gives the probability of this genealogy, given a scaled mutation rate \[Theta]=4N\[VeryThinSpace]\[Mu]. By default, the number of mutations is deduced from a list of unique mutations held in the second element of the information list.  NodeFunction\[Rule]f uses f[i,info] to find the number of mutations. Uses MomentGeneratingFunction[], and so is intractable for large numbers of mutations and for large genealogies.  ExactProbability[S,\[Theta]] uses the generating function over all topologies to find the net probability of the configuration of mutations represented by the matrix S.";


(* ::Input::Initialization:: *)
GenealogyToMatrix::usage="GenealogyToMatrix[g] gives a matrix whose rows specify which mutations are found in which leaf of the genealogy. The genealogy can be unrooted. By default, the list of mutations is taken from the second element of the information list.  NodeFunction\[Rule]f uses f[i,info] to specify the mutations in each node.  MutationLabels->{\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]} specifies the names of the mutations; by default, the list is the set of mutations found in g.";


(* ::Input::Initialization:: *)
MatrixToGenealogy::usage="MatrixToGenealogy[S,{\!\(\*SubscriptBox[\(leaf\), \(1\)]\), \!\(\*SubscriptBox[\(leaf\), \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[\(\[Mu]\), \(1\)]\),\[Ellipsis]}] constructs a genealogy from the matrix S.  The leaves are labelled by {\!\(\*SubscriptBox[\(leaf\), \(1\)]\), \[Ellipsis]} and the mutations by {\!\(\*SubscriptBox[\(\[Mu]\), \(1\)]\),\[Ellipsis]}; internal nodes are labelled by unique integers.  Unrooted->True yields an unrooted genealogy; no assumption is made as to which allele is ancestral and which derived.";


(* ::Input::Initialization:: *)
MatrixToList::usage="MatrixToList[S] converts a matrix representation to a list of the mutations held by each leaf.  By default, mutations are numbered 1,2\[Ellipsis].  MutationLabels\[Rule]{\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]} uses the specified labels.";


(* ::Input::Initialization:: *)
FindNode::usage="FindNode[g,{\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]},newNode] finds from where in the genealogy g a leaf carrying mutations {\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]} descends.  If no node or branch matches, returns $Failed. If the leaf joins the branch above node i, returns {i,newNode,{\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]}}, where newNode is a new node label, distinct from any other in g. The last element lists the mutations carried at the new node.  If the leaf joins at node i, returns {i,i,{\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]}}, where the last element lists the mutations carried at node i.    The new leaf MUST contain all the mutations in the root node of g, and g must carry at least one mutation on each branch, except for branches loeading down to leaves.";


(* ::Input::Initialization:: *)
MutationLabels::usage="MutationLabels is an option for MatrixToList[] which labels the mutations.";


(* ::Input::Initialization:: *)
ListToMatrix::usage="ListToMatrix[{{1,2,3},{4},\[Ellipsis]}] converts a list of mutations present at each node into a matrix representation.  MutationLabels\[Rule]{\!\(\*SubscriptBox[\(m\), \(1\)]\),\[Ellipsis]} gives the columns in the specified order.";


(* ::Input::Initialization:: *)
GriffithsTavare::usage="GriffithsTavare[S,\[Theta]] uses the Griffiths-Tavare algorithm to find the probability of a configuration of mutations defined by the matrix S.";


(* ::Input::Initialization:: *)
MonteCarloGriffithsTavare::usage="MonteCarloGriffithsTavare[S,\[Theta]] uses the Monte-Carlo Griffiths-Tavare algorithm to find the probability of a configuration of mutations defined by the matrix S.";


(* ::Input::Initialization:: *)
ValidMatrixQ::usage="ValidMatrixQ[S] determines whether a matrix of mutations, S, is compatible with a genealogy. The i'th row of S is a list of {1,0,\[Ellipsis]} representing the set of mutations present in the i'th leaf. Unrooted\[Rule]True does not assume that a '1' represents a new mutation: 0, 1 just represent two alternative alleles. ValidMatrixQ[{0,1\[Ellipsis]},{1,0,\[Ellipsis]}] tests a particular pair of mutations.";


(* ::Input::Initialization:: *)
Unrooted::usage="Unrooted is an option for ValidMatrixQ which specifies that the genealogy is unrooted - i.e., no assumption is made about which allele is ancestral";


(* ::Input::Initialization:: *)
SwapStates::usage="SwapStates[s,S] swaps the states of mutations listed in the matrix S, according to the specification s.  The matrix S has dimensions # leaves\[Times]# mutations, and s is a vector of length equal to the # of mutations.  Both consist of 0 or 1.";


(* ::Input::Initialization:: *)
MissingCombination::usage="MissingCombination[S] tabulates the missing combinations for each pair of mutations listed in S.  Each element contains {} if there are less than 3 combinations for that pair.  If there are 4 combinations, the matrix is invalid, and an error message is returned.  If there are three combinations, the missing combination is returned; swaps represented by this combination are not allowed.  Stores results.";


(* ::Input::Initialization:: *)
PossibleRootings::usage="PossibleRootings[S] lists all valid ways of rooting the mutations listed in S. Returns a list, in which each row {0,1,\[Ellipsis]} indicates whether an allele `1` is to be taken as ancestral (1) or derived (0). PossibleRootings[{{Null,0,1,Null\[Ellipsis]},\[Ellipsis]},S] eliminates indeterminate mutations, indicated by Null, until the solution is found.";


(* ::Input::Initialization:: *)
AddMutation::usage="AddMutation[n,m,g] adds the mutations m to node n; m can be one mutation,or a list of mutations. ";


(* ::Input::Initialization:: *)
(*AddMutation[{Subscript[n, 1],Subscript[n, 2],\[Ellipsis]},{Subscript[m, 1],Subscript[m, 2],\[Ellipsis]},g] adds to a list of nodes. Mutations are held as the second element of the information list.  ";*)


(* ::Input::Initialization:: *)
CondenseMatrix::usage="CondenseMatrix[S] reduces the matrix S to the minimum informative size. Columns depicting mutations with the same distribution across leaves, mutations fixed across the whole set, or present in only one leaf, are removed.  Unrooted->True also removes one of each pair of complementary mutations (e.g. {0,0,1,1} and {1,1,0,0}).";


(* ::Input::Initialization:: *)
AncestralLineage::usage="AncestralLineage[l, {t0, t1}, {{a, b}, {}, {c, d}, {c}}, {r1, r2, r3, R}, {info}] represents one lineage in an ancestral graph.  It gives the name of the lineage, l; the timespan, {t0,t1}; the leaves which descend from the various segments, {{a,b},{},{c,d},{c}}; and the rightmost positions of each segment, {r1,r2,r3,R}.  The genome spans {0,R}.";


(* ::Input::Initialization:: *)
AncestralGraphPattern::usage="AncestralGraphPattern is matched by a list {AncestralLineage[\[Ellipsis]]...}, representing an ancestral graph. No detailed checks are made that this is a valid graph, however.";


(* ::Input::Initialization:: *)
AncestralLineagePattern::usage="AncestralLineagePattern is matched by an AncestralLineage[\[Ellipsis]]";


(* ::Input::Initialization:: *)
ExtractLabel::usage="ExtractLabel is a rule which replaces AncestralLineage[l,\[Ellipsis]] by its label, l.";


(* ::Input::Initialization:: *)
CoalesceLineages::usage="CoalesceLineages[AncestralLineage[l1,\[Ellipsis]],AncestralLineage[l2,\[Ellipsis]],l12,t] gives a lineage l12 which is ancestral to l1, l2, generated by a coalescence event at time t.  By default, corresponding elements of information lists are put into a set; InformationFunction\[Rule]f generates a new information list f[\!\(\*SubscriptBox[\(i\), \(1\)]\),\!\(\*SubscriptBox[\(i\), \(2\)]\)]";


(* ::Input::Initialization:: *)
InformationFunction::usage="InformationFunction->f is an option for functions dealing with ancestral graphs, which specifies how the information associated with each lineage should be handled.";


(* ::Input::Initialization:: *)
RecombineLineage::usage="RecombineLineage[AncestralLineage[l,\[Ellipsis]],{lL,lR},x,t] generates two recombinant lineages, with breakpoint at map position x, and labelled lL, lR. By default, the information lists are duplicated; InformationFunction\[Rule]{fL,fR} generates a pair of information lists {fL[i],fR[i]}.";


(* ::Input::Initialization:: *)
Junctions::usage="Junctions[AncestralLineage[\[Ellipsis]]] lists the junctions present in the lineage.  Junctions[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists all the junctions present in the ancestral graph. ";


(* ::Input::Initialization:: *)
MapLength::usage="MapLength[AncestralLineage[\[Ellipsis]]] or MapLength[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] gives the map length, R. ";


(* ::Input::Initialization:: *)
LineagesPresent::usage="LineagesPresent[{AncestralLineage[\[Ellipsis]],\[Ellipsis]},t] gives the set of lineages present at time t. LineagesPresent[{AncestralLineage[\[Ellipsis]],\[Ellipsis]}] lists all lineages";


(* ::Input::Initialization:: *)
RecombinantLineages::usage="RecombinantLineages[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] gives lineages which start at the same time as a sister lineage";


(* ::Input::Initialization:: *)
CoalescentLineages::usage="CoalescentLineages[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] gives lineages which start at the same time as two other lineages end";


(* ::Input::Initialization:: *)
RootLineages::usage="RootLineages[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] gives lineages which end when no other lineages begin.";


(* ::Input::Initialization:: *)
ExtractLineage::usage="ExtractLineage[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},l] extracts the lineage labelled by l. Checks that there is only one such lineage. ExtractLineage[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},{\!\(\*SubscriptBox[\(l\), \(1\)]\),\[Ellipsis]}] extracts a list of lineages. ";


(* ::Input::Initialization:: *)
ExtractLineagesEndingAtT::usage="ExtractLineagesEndingAtT[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},t] extracts those lineages which end at time t.  These are either root lineages, with no ancestors, or are generated by a coalescence or recombination.  Checks that these are present in the appropriate numbers.";


(* ::Input::Initialization:: *)
ExtractLineagesStartingAtT::usage="ExtractLineagesStartingAtT[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},t] extracts those lineages which start at time t.  These are either leaves, with no descendants, or are generated by a coalescence or recombination.  Checks that these are present in the appropriate numbers.";


(* ::Input::Initialization:: *)
TimesOfEvents::usage="TimesOfEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists all the times at which lineages begin or end.";


(* ::Input::Initialization:: *)
AllEvents::usage="AllEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists all events at which lineages begin or end, in the form {t,descendants,ancestors,map position}. (The last element is set if there has been a recombination event; otherwise it is None).";


(* ::Input::Initialization:: *)
CoalescenceEvents::usage="CoalescenceEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists events at which lineages {\!\(\*SubscriptBox[\(l\), \(1\)]\),\[Ellipsis]} coalesce into lineage \!\(\*SubscriptBox[\(l\), \(p\)]\), in the form {t,{\!\(\*SubscriptBox[\(l\), \(1\)]\),\!\(\*SubscriptBox[\(l\), \(2\)]\)},\!\(\*SubscriptBox[\(l\), \(P\)]\)}.";


(* ::Input::Initialization:: *)
NullLineages::usage="NullLineages[g] lists those lineages which contain no material ancestral to the sample.";


(* ::Input::Initialization:: *)
RecombinationEvents::usage="RecombinationEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists events at which a lineages \!\(\*SubscriptBox[\(l\), \(1\)]\) splits into two lineage {\!\(\*SubscriptBox[\(l\), \(L\)]\), \!\(\*SubscriptBox[\(l\), \(R\)]\)} in the form {t,{\!\(\*SubscriptBox[\(l\), \(p\)]\)},{\!\(\*SubscriptBox[\(l\), \(L\)]\),\!\(\*SubscriptBox[\(l\), \(R\)]\)},r}.";


(* ::Input::Initialization:: *)
NullRecombinationEvents::usage="NullRecombinationEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists events at which a lineages \!\(\*SubscriptBox[\(l\), \(1\)]\) splits into two lineages {\!\(\*SubscriptBox[\(l\), \(L\)]\), \!\(\*SubscriptBox[\(l\), \(R\)]\)}, but where one of these is null.  These have the form {t,{\!\(\*SubscriptBox[\(l\), \(p\)]\)},{\!\(\*SubscriptBox[\(l\), \(L\)]\),\!\(\*SubscriptBox[\(l\), \(R\)]\)},R}.";


(* ::Input::Initialization:: *)
LeafEvents::usage="LeafEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists events at which a lineages becomes extinct.";


(* ::Input::Initialization:: *)
RootEvents::usage="RootEvents[{AncestralLineage[\[Ellipsis]]\[Ellipsis]}] lists events at which an ancestral lineage begins.";


(* ::Input::Initialization:: *)
TimespanOfLineage::usage="TimespanOfLineage[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},l] gives the start and end times,{t0,t1}, of lineage l.";


(* ::Input::Initialization:: *)
MapPosition::usage="MapPosition\[Rule]x is an option for Descendants which specifies that only descendants at map position x are counted.";


(* ::Input::Initialization:: *)
AddDescendants::usage="AddDescendants[g,{l}] returns {l,Descendants[g,l]}.";


(* ::Input::Initialization:: *)
AncestorList::usage="AncestorList is an option for Ancestors; it may be set to Previous, All or Roots";


(* ::Input::Initialization:: *)
AddAncestors::usage="AddAncestors[g,{l}] returns {l,Ancestors[g,l]}.";


(* ::Input::Initialization:: *)
DeleteNullLineages::usage="DeleteNullLineages[g] deletes ancestral lineages that have no descedants.  DeleteNullLineages is also an option for AddRecombinantLineages which specifies whether lineages carrying no material ancestral to thhe sample are to be included.";


(* ::Input::Initialization:: *)
AddRecombinantLineages::usage="AddRecombinantLineages[g,l,{lL,lR},x,t] terminates lineage l, and adds two recombinant lineages {lL,lR} to the list g. DeleteNullLineages->True ignores null recombination events.";


(* ::Input::Initialization:: *)
AddCoalescentLineage::usage="AddCoalescentLineage[g,{l1,l2},lC,t] terminates lineages {l1,l2} at t, and adds a coalescent lineage lC to the list g.";


(* ::Input::Initialization:: *)
PrintDetails::usage="PrintDetails is an option for RandomGenealogy";


(* ::Input::Initialization:: *)
Segments::usage="Segments[AncestralLineage[\[Ellipsis]],l] gives the blocks ancestral to l present within the lineage.  Segments[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},l] applies to several lineages";


(* ::Input::Initialization:: *)
PlotSegments::usage="PlotSegments[AncestralLineage[\[Ellipsis]],leaf,y] gives a Graphics[] object depicting the segments ancestral to the leaf; drawn at height y.  SegmentStyle\[Rule]{Blue,\[Ellipsis]} and BackgroundStyle\[Rule]{Yellow,\[Ellipsis]} set the style of the lines.  PlotSegments[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},leaf,{y0,y1}] plots a series of lineages spanning {y0,y1}; JunctionStyle specifies vertical lines depicting the junctions. ";


(* ::Input::Initialization:: *)
BackgroundStyle::usage="BackgroundStyle is an option for PlotSegments which sets the style of non-ancestral parts of the chromosome; default {Yellow}";


(* ::Input::Initialization:: *)
SegmentStyle::usage="SegmentStyle is an option for PlotSegments which sets the style of ancestral parts of the chromosome; default {Blue}";


(* ::Input::Initialization:: *)
JunctionStyle::usage="JunctionStyle is an option for PlotSegments which sets the style of vertical lines depicting junctions; default {Black}";


(* ::Input::Initialization:: *)
TimespanOfJunction::usage="TimespanOfJunction[{AncestralLineage[\[Ellipsis]]\[Ellipsis]},j] finds the first and last occurrence of j. ";


(* ::Input::Initialization:: *)
FixedQ::usage="FixedQ[AncestralLineage[\[Ellipsis]],lvs] tests whether this ancestral lineage only contains segments ancestral to the entire set lvs.  Can also apply to an ancestral graph";


(* ::Input::Initialization:: *)
MaxTime::usage="MaxTime is an option for RandomGenealogy which specifies the maximum time to run the coalescent with recombination.";


(* ::Input::Initialization:: *)
Fixation::usage="Fixation is an option for RandomGenealogy which specifies that the coalescent with recombination stops at fixation";


(* ::Input::Initialization:: *)
MRCA::usage="MRCA[g,{\!\(\*SubscriptBox[\(node\), \(1\)]\),\[Ellipsis]}] gives the most recent common ancestor of the list of nodes.";


(* ::Input::Initialization:: *)
PairwiseDivergence::usage="PairwiseDivergence[g] lists the time to MRCA of all pairs of leaves.  PairwiseDivergence[g,{\!\(\*SubscriptBox[\(node\), \(1\)]\),\!\(\*SubscriptBox[\(node\), \(2\)]\)}] gives the time to the MRCA of these nodes.";


(* ::Input::Initialization:: *)
PairwiseDifference::usage="PairwiseDifference[g] lists the number of sites which differ between randomly chosen pairs.  PairwiseDifference[g,{\!\(\*SubscriptBox[\(node\), \(1\)]\),\!\(\*SubscriptBox[\(node\), \(2\)]\),\[Ellipsis]}] gives the mutations which differ between the nodes, calculated as Complement[Union@@ml,Intersection@@ml]], where ml is a list of the mutations on each of the nodes. ";


(* ::Input::Initialization:: *)
MeanPairwiseDivergence::usage="MeanPairwiseDivergence[g] gives the mean time back to a common ancestor between two genes.";


(* ::Input::Initialization:: *)
ExtractCoalescenceTimes::usage="ExtractCoalescenceTimes[g] extracts a list of the coalescence times.";


(* ::Input::Initialization:: *)
LengthOfGenealogy::usage="LengthOfGenealogy[g] gives the total length of the genealogy.";


(* ::Input::Initialization:: *)
DepthOfGenealogy::usage="DepthOfGenealogy[g] gives the time to the last common ancestor.";


(* ::Input::Initialization:: *)
PairwiseDivergencePlot::usage="PairwiseDivergencePlot[g,{Dmax,\[Delta]}] plots the distribution of pairwise divergence as a histogram, on the range {0,Dmax}.  PairwiseDivergencePlot[{\!\(\*SubscriptBox[\(g\), \(1\)]\),\[Ellipsis]},{Dmax,\[Delta]}] plots the overall distribution for a set of replicate genealogies.";


(* ::Input::Initialization:: *)
PairwiseDifferencePlot::usage="PairwiseDifferencePlot[g,{Dmax,\[Delta]}] plots the distribution of pairwise difference as a histogram, on the range {0,Dmax}.  PairwiseDifferencePlot[{\!\(\*SubscriptBox[\(g\), \(1\)]\),\[Ellipsis]},{Dmax,\[Delta]}] plots the overall distribution for a set of replicate genealogies.";


(* ::Input::Initialization:: *)
BlockSizes::usage="BlockSizes[AncestralLineage[l,{\!\(\*SubscriptBox[\(t\), \(0\)]\),\!\(\*SubscriptBox[\(t\), \(1\)]\)},{{},{\[Ellipsis]},\[Ellipsis]},{\!\(\*SubscriptBox[\(r\), \(1\)]\),\[Ellipsis],R},{\[Ellipsis]}]] returns the sizes of blocks with different descendants. BlockSizes[g] applies to a whole ancestral graph.";


(* ::Input::Initialization:: *)
Muddle[s_List]:=Sort[s,(Random[]<1/2)&];


(* ::Input::Initialization:: *)
Subdivide::usage="Subdivide[{a,b,..},{1,2,3,..}] splits the list into subsets of the specified length.  BEWARE: the lengths must match.";


(* ::Input::Initialization:: *)
Subdivide::lengthMismatch="Length of set `1` does not match that requested,  `2`";


(* ::Input::Initialization:: *)
Subdivide[s_List,{j_Integer,k__Integer}]:=Join[{Take[s,j]},Subdivide[Drop[s,j],{k}]];
Subdivide[s_List,{k_Integer}]:=If[k==Length[s],{s},Message[Subdivide::lengthMismatch,s,k];s];


(* ::Input::Initialization:: *)
RandomSet::usage="RandomSet[j,k] gives a random (ordered) set of j distinct integers in the range {1,k}.  (j\[LessEqual]k).  RandomSet[j,{a,b,..}] gives j randomly chosen elements from the set {a,b,..}. OBSOLETE: replaced by Sort[RandomSample[Range[k],j]] or RandomSample[{a,b,\[Ellipsis]},j]. ";


(* ::Input::Initialization:: *)
RandomSet[j_Integer,s_List]:=Extract[s,List/@RandomSet[j,Length[s]]];
RandomSet[j_Integer,k_Integer]:=RandomSetCompiled[j,k];


(* ::Input::Initialization:: *)
RandomSet[{x__Integer},k_Integer]:=RandomSet[{x},Range[k]];
RandomSet[{x__Integer},s_List]:=Subdivide[RandomSample[s],{x}];


(* ::Input::Initialization:: *)
RandomSetCompiled=Compile[{{j,_Integer},{n,_Integer}},
Module[{aa=Range[n],na=n,ns={},k,new},
If[j>n\[Or]j<0,Message[RandomSet::tooBig]];
If[j<=Quotient[n,2],
Sort[Table[(k=Random[Integer,{1,na}];na-=1;new=aa[[k]];aa=Delete[aa,k];new),{j}]],
Sort[Complement[Range[n],
Table[(k=Random[Integer,{1,na}];na-=1;new=aa[[k]];aa=Delete[aa,k];new),{n-j}]]]]],
{{ns,_Integer,1},{na,_Integer},{k,_Integer},{new,_Integer},{aa,_Integer,1}}];


(* ::Input::Initialization:: *)
RandomSet::tooBig="The number of distinct elements chosen must be no greater than the size of the set.";


(* ::Input::Initialization:: *)
TakeAway::usage="TakeAway[U,V]  gives the set U, minus elements V. Note that this is not the same as Complement[U,V] if U contains repeated elements.  ";


(* ::Input::Initialization:: *)
TakeAway[U_List,{}]:=U;
TakeAway[U_List,{v_}]:=Drop[U,Position[U,v][[1]]]/;Complement[{v},U]=={};
TakeAway[U_List,V_List]:=TakeAway[TakeAway[U,Take[V,1]],Drop[V,1]]/;Complement[V,U]=={};
TakeAway[U_List,W__List,V_List]:=TakeAway[TakeAway[U,W],V];


(* ::Input::Initialization:: *)
ExactIntersection::usage="ExactIntersection[U,V] gives those elements that appear in both U and V. ";


(* ::Input::Initialization:: *)
ExactIntersection[{a___,x_,b___},{c___,x_,d___}]:=Prepend[ExactIntersection[{a,b},{c,d}],x];
ExactIntersection[a_List,b_List]:=If[Intersection[a,b]=={},{},ExactIntersection[a,b]];


(* ::Input::Initialization:: *)
Options[CollapseGenealogy]={Node->True,NodeFunction->(#1&),Nested->True};


(* ::Input::Initialization:: *)
CollapseGenealogy[g_Node,opts___Rule]:=Module[{ff=NodeFunction/.{opts}/.Options[CollapseGenealogy]},If[Nested/.{opts}/.Options[CollapseGenealogy],
If[Node/.{opts}/.Options[CollapseGenealogy],g//.{Node[i_,s_List,{m___Node}]:>{ff[i,s],{m}}}/.{{i_,{}}:>i},
		g//.{Node[i_,s_List,{m__Node}]:>{m},Node[i_,s_List,{}]:>ff[i,s]}],
If[Node/.{opts}/.Options[CollapseGenealogy],
				Extract[{g},#]&/@Position[{g},Node[i_,s_List,{m___Node}]],
	Extract[{g},#]&/@Position[{g},Node[i_,s_List,{}]]]//.Node[i_,s_List,{m___Node}]:>ff[i,s]]];


(* ::Input::Initialization:: *)
CollapseGenealogy[{g__Node},opts___Rule]:=Module[{ff=NodeFunction/.{opts}/.Options[CollapseGenealogy]},If[Node/.{opts}/.Options[CollapseGenealogy],
				{g}/.Node[i_,s_List,_List]:>ff[i,s],
	       Cases[{g}, Node[_,_,{_}]]/.Node[i_,s_List,{_}]:>ff[i,s]]];


(* ::Input::Initialization:: *)
Nodes[g_Node]:=Extract[{g},#][[1]]&/@Position[{g},Node[_,_List,{___Node}]];


(* ::Input::Initialization:: *)
Nodes[{g___Node}]:=	{g}/.Node[i_,_List,_List]:>i;


(* ::Input::Initialization:: *)
InternalNodes[g_Node]:=Extract[{g},#][[1]]&/@Position[{g},Node[_,_List,{m__Node}]];


(* ::Input::Initialization:: *)
InternalNodes[{g___Node}]:=Complement[Nodes[{g}],Leaves[{g}]];


(* ::Input::Initialization:: *)
Leaves[g_Node]:=Extract[{g},#][[1]]&/@Position[{g},Node[i_,s_List,{}]];


(* ::Input::Initialization:: *)
Leaves[{g___Node}]:=Cases[{g}, Node[_,_List,{_}]]/.Node[i_,_List,{_}]:>i;


(* ::Input::Initialization:: *)
ExtractInformation[g_Node,i_]:=Module[{ps=Position[g,Node[i,_List,_List]]},
		Switch[Length[ps],
			1,Extract[g,Append[ps[[1]],2]],
			0,Print[i," does not appear in ",g];,
			_,Print[i," appears more than once in ",g]]];


(* ::Input::Initialization:: *)
ExtractInformation[g_Node]:=ExtractInformation[g,#]&/@Nodes[g];


(* ::Input::Initialization:: *)
ExtractInformation[{___Node,Node[i_,info_List,_List],___Node},i_]:=info;


(* ::Input::Initialization:: *)
ExtractInformation[{g__Node}]:=ExtractInformation[{g},#]&/@Nodes[{g}];


(* ::Input::Initialization:: *)
TransformInformation[g_Node,f_]:=g//.{Node[i_,si_List,{nn___Node}]:>NodeTemp[i,f[i,si],{nn}]}/.{NodeTemp->Node};


(* ::Input::Initialization:: *)
TransformInformation[{g__Node},f_]:={g}//.{Node[i_,si_List,{nn___}]:>NodeTemp[i,f[i,si],{nn}]}/.{NodeTemp->Node};


(* ::Input::Initialization:: *)
DeleteGenealogy[g_Node,i_]:=Module[{ps=Position[g,Node[i,_List,_List]]},
		Switch[Length[ps],
			1,Delete[g,ps[[1]]],
			0,Print[i," does not appear in ",g];,
			_,Print[i," appears more than once in ",g]]];


(* ::Input::Initialization:: *)
CondenseGenealogy[g_Node]:=g//.{Node[p_,pi_List,{m1___Node,Node[x_,y_List,{z_Node}],m2___Node}]:>Node[p,pi,{m1,z,m2}]};


(* ::Input::Initialization:: *)
ExtractGenealogy[g_Node,i_]:=Module[{ps=Position[g,Node[i,_List,_List]]},
		Switch[Length[ps],
			1,If[ps[[1]]=={},g,Extract[g,ps[[1]]]],
			0,Print[i," does not appear in ",g];,
			_,Print[i," appears more than once in ",g]]];


(* ::Input::Initialization:: *)
AddGenealogy[g1_Node,g2_Node,nn_,nn_]:=g1/.{Node[nn,s1_List,{n1___}]:>Node[nn,s1,{n1,g2}]};
AddGenealogy[g1_Node,g2_Node,nn_,nn_,info_]:=AddGenealogy[g1,g2,nn,nn];


(* ::Input::Initialization:: *)
AddGenealogy[g1_Node,g2_Node,i_,nn_,info_]:=g1/.{Node[i,s1_List,n1_List]:>Node[nn,info,{Node[i,s1,n1],g2}]};


(* ::Input::Initialization:: *)
AddGenealogy[{g1__Node},{g2__Node},i1_,i2_]:={g1,g2}/.{Node[i1,inf1_,{a___}]:>Node[i1,inf1,{a,i2}],Node[i2,inf2_,{a___}]:>Node[i2,inf2,{a,i1}]}//Sort;


(* ::Input::Initialization:: *)
AddNode[g_Node,i_,k_,info_] :=
	g/.Node[i,si_,{m___Node}]:>Node[k,info,{Node[i,si,{m}]}];


(* ::Input::Initialization:: *)
AddNode[{g__Node},i_,j_,k_,info_] :=
{g,Node[k,info,{i,j}]}/.{Node[i,si_,{m___Node}]:>Node[i,si,{m,k}],Node[j,sj_,{m___Node}]:>Node[j,sj,{m,k}]};


(* ::Input::Initialization:: *)
Options[ListToGenealogy]={Node->True,NodeFunction->({}&)};


(* ::Input::Initialization:: *)
ListToGenealogy[s_List,opts___Rule]:=Module[{ff=NodeFunction/.{opts}/.Options[ListToGenealogy]},
		If[Node/.{opts}/.Options[ListToGenealogy],
			s//.{List[i_,{m___}]:>Node[i/.List->ListTemp,(ff[i]/.List->ListTemp),ListTemp[m]]},
		s//.{m___}:>Node[ListTemp[],ListTemp[],ListTemp[m]]]/.{ListTemp->List}//.{Node[i_,z_List,{x___,m_?((FreeQ[#,Node]&&FreeQ[#,NodeTemp])&),y___}]:>Node[i,z,{x,NodeTemp[m,ff[m],{}],y}]}/.NodeTemp->Node];


(* ::Input::Initialization:: *)
Options[OrderedNodes]={Node->False};


(* ::Input::Initialization:: *)
OrderedNodes[g_Node,f_,opts___Rule] :=
	Module[{tt=CollapseGenealogy[g,NodeFunction->f],nn=CollapseGenealogy[g],leaves},
		If[Node/.{opts}/.Options[OrderedNodes],
		  leaves=CollapseGenealogy[g,Node->False];
		  Select[OrderedNodes[g,f],(FreeQ[leaves, #])&],
		Join@@(Extract[nn,#]&/@Position[tt, #]&/@(Sort[Union[tt//Flatten]]))]];


(* ::Input::Initialization:: *)
Ancestors[g_Node,i_]:=g/.Node[i,{___},{Node___}]:>{None}//.Node[j_,{___},{___,{None,k___},___}]:>{None,j,k}/.{None,j___}:>{j};


(* ::Input::Initialization:: *)
Options[Descendants]={DescendantList->Next};


(* ::Input::Initialization:: *)
Descendants[g_Node,i_,opts___Rule]:=
	Module[{dl=DescendantList/.{opts}/.Options[Descendants],tt,dd,ddn},
		Switch[dl,
		  Next,
		    Last[ExtractGenealogy[g,i]]/.Node[j_,_List,_List]:>j,
		  All,
		    tt=dd=Descendants[g,i];
         While[Length[dd]>0,
				  ddn={};Scan[(ddn=Join[ddn,Descendants[g,#]])&,dd];
				  dd=ddn;
				  tt=Join[tt,dd]];tt,
		  Leaves,
		    Intersection[Descendants[g,i,DescendantList->All],Leaves[g]],
		  _,
		    Print[dl," is not a valid setting for DescendantList"];
			$Failed]];


(* ::Input::Initialization:: *)
Descendants[{g__Node},i_]:=Cases[{g},Node[i,_List,_List]]/.{{Node[_,_List,s_List]}:>s};


(* ::Input::Initialization:: *)
MostRecentCommonAncestor[g_Node,i_,j_] :=First[Intersection[Ancestors[g,i],Ancestors[g,j]]];


(* ::Input::Initialization:: *)
UnrootedGenealogy[g_Node]:=Module[{aa,dd},
		(aa=Ancestors[g,#[[1]]];dd=Descendants[g,#[[1]]];
	Node[#[[1]],#[[2]],If[aa==={},dd,Append[dd,Last[aa]]]])&/@Sort[CollapseGenealogy[g,Nested->False,NodeFunction->({#1,#2}&)]]];


(* ::Input::Initialization:: *)
RootedGenealogy[{g__Node},k_]:=Node[k,ExtractInformation[{g},k],List/@Descendants[{g},k]]//.{Node[i_,si_List,{m__List}]:>
						Node[i,si,Node[#[[1]],ExtractInformation[{g},#[[1]]],
						List/@DeleteCases[Descendants[{g},#[[1]]],i]]&/@{m}]};


(* ::Input::Initialization:: *)
SiblingList[g_Node] :=Module[{
			leaves=Leaves[g],
			nodes=InternalNodes[g],
			dl,ff,ss,i,j,n},
		n=Length[leaves];
		dl=Descendants[g,#]&/@nodes;
	 ff[{x_,y_}]:=Or@@((MemberQ[#, x]&&MemberQ[#, y])&/@dl);
	  ss=Flatten[Table[{leaves[[i]],leaves[[j]]},{i,2,Length[leaves]},{j,i-1}],1];
	  Select[ss,ff]];


(* ::Input::Initialization:: *)
SizeOfGenealogyPlot[g_Node]:=Module[{ei=Transpose[Last/@ExtractInformation[g]]},
		{Min/@ei,Max/@ei}];


(* ::Input::Initialization:: *)
MakeGenealogyPlot[ Node[i_,si_,{}]]:=Node[i,Append[si,{0,0}],{}];


(* ::Input::Initialization:: *)
MakeGenealogyPlot[Node[i_,si_List,{nn__Node}]]:=
	Module[{k=Length[{nn}],j,gl=MakeGenealogyPlot/@{nn},xl,xt,al,ngl},
		sl=SizeOfGenealogyPlot/@gl;
		xl=(#[[2,1]]-#[[1,1]])&/@sl;
		al=Range[0,k]+FoldList[Plus,0,xl];
		ngl=Table[TransformInformation[gl[[j]],(ReplacePart[#2,{#2[[-1,1]]+al[[j]],#2[[-1,2]]},-1]&)],{j,k}];Node[i,Append[si,{(Last[al]-1)/2,1+Max[(#/.{{_,_},{_,y_}}:>y)&/@sl]}],ngl]];


(* ::Input::Initialization:: *)
Options[PlotGenealogy]={NodeFunction->(#2[[-1]]&),NodeLabels->(#1&),LeafLabels->(#1&),MakeGenealogyPlot->True,LeafOffset->{0,-0.2},NodeOffset->{-0.2,0.2}};


(* ::Input::Initialization:: *)
PlotGenealogy[gg_Node,opts___Rule]:=Module[{nf=NodeFunction/.{opts}/.Options[PlotGenealogy],nlab,llab,
		   lv=Leaves[gg],nl=Nodes[gg],
			 dl,ll,j,gl,nlF,llF,g,
			 lo=LeafOffset/.{opts}/.Options[PlotGenealogy],
			 no=NodeOffset/.{opts}/.Options[PlotGenealogy]},
		g=If[MakeGenealogyPlot/.{opts}/.Options[PlotGenealogy],MakeGenealogyPlot[gg],gg];
		nlF=NodeLabels/.{opts}/.Options[PlotGenealogy];
		llF=LeafLabels/.{opts}/.Options[PlotGenealogy];
		nl=Complement[nl,lv];dl=(Descendants[g,#]&/@nl);
	  ll=Flatten[Table[{nl[[j]],#}&/@dl[[j]],{j,Length[dl]}],1];
	  gl=Line[{nf[#[[1]],ExtractInformation[g,#[[1]]]],nf[#[[1]],ExtractInformation[g,#[[2]]]]}]&/@ll;
	  nlab=ExtractInformation[g,#]&/@nl;
		nlab=If[nlF===None,
				{},
			MapThread[Text,{MapThread[nlF,{nl,nlab}],
						((nf[#,ExtractInformation[g,#]]+no)&/@nl)}]];
     llab=ExtractInformation[g,#]&/@lv;
		 llab=If[llF===None,
				{},
			MapThread[Text,{MapThread[llF,{lv,llab}],
						((nf[#,ExtractInformation[g,#]]+lo)&/@lv)}]];
Graphics[Join[gl,nlab,llab],PlotRange->(Transpose[SizeOfGenealogyPlot[g]]+{{-1,1},{-1,1}})]];


(* ::Input::Initialization:: *)
GenealogyToFamily[g_Node,f_]:=Module[{no=OrderedNodes[g,f],leaves=CollapseGenealogy[g,Node->False],ng,fl},
		no=Select[no,(FreeQ[leaves, #])&];
		ng=g//.Node[i_,s_List,m_List]:>NodeTemp[i,{NumberOfLineages[g,i]},m]/.NodeTemp->Node;
		fl=FoldList[(#1/.Node[#2,x_,m_List]:>Node[#2,x,{}])&,ng,no];
		Flatten[CollapseGenealogy[#,Node->False,NodeFunction->(#2&)]]&/@fl];


(* ::Input::Initialization:: *)
Options[FamilyToGenealogy]={NodeInformation->None,LeafInformation->None,NodeLabels->None};


(* ::Input::Initialization:: *)
FamilyToGenealogy[ls_,sf_,opts___Rule]:=Module[{ss,ds,ts,j,k,n=Length[sf],nl,ni,li},ni=NodeInformation/. {opts}/. Options[FamilyToGenealogy];nl=NodeLabels/. {opts}/. Options[FamilyToGenealogy];li=LeafInformation/. {opts}/. Options[FamilyToGenealogy];If[nl==None,nl=Range[n]];If[ni==None,ni=({}&)/@nl];If[li==None,li=({}&)/@nl];ss=Node[nl[[-1]],ni[[-1]],MapThread[Node[#1,#2,{}]&,{ls,li}]];Do[ds=Reverse[Sort[Tally[TakeAway[sf[[j]],ExactIntersection[sf[[j]],sf[[j+1]]]]]],2];ts=Flatten[Table[RandomSample[Select[ss[[3]],NumberOfLineages[#1]==ds[[k,2]]&],ds[[k,1]]],{k,Length[ds]}],1];ss=Node[nl[[-1]],ni[[-1]],Append[TakeAway[ss[[3]],ts],Node[nl[[j]],ni[[j]],ts]]],{j,n-1}];ss];


(* ::Input::Initialization:: *)
GenealogyB[k_,k_,k_]:=GenealogyB[k,k,k]=1;
GenealogyB[j_,i_,k_]:=GenealogyB[j,i,k]=If[i<j,0,
			If[i==j,-\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(ii = j + 1\), \(k\)]\(GenealogyB[j, ii, k]\)\),(j(j+1))/(j(j-1)-i(i-1)) GenealogyB[j+1,i,k]]];


(* ::Input::Initialization:: *)
CoalescenceDistribution[j_,k_,t_]:=Module[{i},Sum[GenealogyB[j,i,k]Exp[-i(i-1)t/2],{i,j,k}] ];


(* ::Input::Initialization:: *)
SimplifyFamilies={{x___List,{n1a_,a_},y___List,{n2a_,a_},z___List}:>Sort[{x,{n1a+n2a,a},y,z}]};


(* ::Input::Initialization:: *)
FamilyProbability[{x__Integer}]:=FamilyProbability[Frequencies[{x}]];
FamilyProbability[{{_,1}}]:=1;


(* ::Input::Initialization:: *)
FamilyProbability[s_List]:=FamilyProbability[s/.SimplifyFamilies]=Module[{ss,i,\[Alpha],l,j,tl,tr,ni,mi,nm,ns,n1,n2},
		ss=s/.SimplifyFamilies;l=Length[ss];j=NumberOfFamilies[ss];
			Sum[(tl=Take[ss,i-1];
				ni=ss[[i,2]];	mi=ss[[i,1]];nm={mi-1,ni};
				tr=Take[ss,-(l-i)];If[mi>1,tr=Prepend[tr, nm]];
			Sum[(ns=Join[tl,{{1,\[Alpha]},{1,ni-\[Alpha]}},tr]//.SimplifyFamilies;
					n1=ns/.{___,{x_,\[Alpha]},___}->x;	
							n2=ns/.{___,{x_,ni-\[Alpha]},___}->x;
						If[\[Alpha]==ni-\[Alpha],(n1(n1-1))/(j(j+1)),(n1 n2)/(j(j+1))]FamilyProbability[ns]),{\[Alpha],1,ni-1}]),{i,1,l}]];


(* ::Input::Initialization:: *)
NumberOfLineages[{s__Integer}]:=NumberOfLineages[Frequencies[{s}]];
NumberOfLineages[{s___Integer}]:=Plus@@((Times@@#)&/@{s});
NumberOfLineages[g_Node]:=Length[Position[g,Node[_,_List,{}]]];
NumberOfLineages[g_Node,i_]:=Length[Position[ExtractGenealogy[g,i],Node[_,_List,{}]]];
NumberOfLineages[{g__Node}]:=Count[{g},Node[_,_,{_}]];
NumberOfLineages[{g__Node},_]:=NumberOfLineages[{g}];


(* ::Input::Initialization:: *)
PairwiseIdentity[{s__Integer}]:=PairwiseIdentity[Frequencies[{s}]];
PairwiseIdentity[s__List]:=Module[{i,k=NumberOfLineages[s]},
Sum[s[[i,1]]s[[i,2]](s[[i,2]]-1),{i,1,Length[s]}]/(k(k-1))];


(* ::Input::Initialization:: *)
AllSets[1]={{{1,1}}};
AllSets[k_Integer]:=AllSets[k]=
			Union[Sort/@Flatten[NewS/@AllSets[k-1],1]];


(* ::Input::Initialization:: *)
AllSets[1,1]={{{1,1}}};
AllSets[j_Integer,k_Integer]:=AllSets[j,k]=
			If[(j==0)||(k==0),{},Union[Sort/@Flatten[Join[NewS[#,same]&/@AllSets[j,k-1],NewS[#,diff]&/@AllSets[j-1,k-1]],1]]];


(* ::Input::Initialization:: *)
NewS[s_,same]:=Module[{i,l=Length[s],tl,tr,ni,mi},
	Table[(tl=Take[s,i-1];
				ni=s[[i,2]];	mi=s[[i,1]];nm={mi-1,ni};
				tr=Take[s,-(l-i)];If[mi>1,tr=Prepend[tr, nm]];
		Join[tl,{{1,ni+1}},tr]//.SimplifyFamilies),{i,1,l}]];
NewS[s_,diff]:={Prepend[s,{1,1}]//.SimplifyFamilies};
NewS[s_]:=Join[NewS[s,diff],NewS[s,same]];


(* ::Input::Initialization:: *)
NumberOfFamilies[{s__Integer}]:=NumberOfFamilies[Frequencies[{s}]];
NumberOfFamilies[s__List]:=(Plus@@s)[[1]];


(* ::Input::Initialization:: *)
RandomCoalescenceTimes[k0_]:=Module[{k=k0+1},Drop[FoldList[Plus,0,Table[k-=1;Random[ExponentialDistribution[(k(k-1))/2]],{k0-1}]],1]];


(* ::Input::Initialization:: *)
RandomCoalescenceTimesG[k0_,0|0.]:=RandomCoalescenceTimes[k0];RandomCoalescenceTimesG[k0_,\[Lambda]_]:=Log[Clip[1+\[Lambda] RandomCoalescenceTimes[k0],{0,\[Infinity]}]]/\[Lambda];


(* ::Input::Initialization:: *)
NumberOfCoalescences[k_Integer,T_]:=NumberOfCoalescences[RandomCoalescenceTimes[k],T];


(* ::Input::Initialization:: *)
NumberOfCoalescences[tl_List,T_]:=Length[Select[tl,(#<T)&]];


(* ::Input::Initialization:: *)
TotalLength[tl_List]:=Plus@@tl+Last[tl];


(* ::Input::Initialization:: *)
RandomFamilies[k_Integer]:=NestList[RandomPreviousFamily,Array[1&,k],k-1];


(* ::Input::Initialization:: *)
RandomPreviousFamily[{k_Integer}]:={k};
RandomPreviousFamily[n_List]:=Module[{rp,k=Length[n],n2},
		(*rp=RandomSet[2,k];*)
rp=Sort[RandomSample[Range[k],2]];
n2=n[[rp[[2]]]];Sort[ReplacePart[Delete[n,rp[[2]]],n2+n[[rp[[1]]]],rp[[1]]]]];


(* ::Input::Initialization:: *)
Options[RandomGenealogy]={NodeLabels->None,MutationRate->None,CoalescenceTimes->Random};


(* ::Input::Initialization:: *)
RandomGenealogy[ls_,opts___Rule]:=
	Module[{n=Length[ls],nl,li,ni,mu,\[Mu]T,rt,rg,nm=0,j,\[Lambda]},
		rt=CoalescenceTimes/.{opts}/.Options[RandomGenealogy];
             If[rt===Random,rt=RandomCoalescenceTimes[n]];
		nl=NodeLabels/.{opts}/.Options[RandomGenealogy];
		mu=MutationRate/.{opts}/.Options[RandomGenealogy];
		li=If[mu===None,Array[{0}&,n],Array[{0,\[Mu]T}&,n]];
		ni=If[mu===None,(List/@rt),{#,\[Mu]T}&/@rt];
		rg=FamilyToGenealogy[ls,RandomFamilies[n],NodeLabels->nl,NodeInformation->ni,LeafInformation->li];
	If[mu===None,
			rg,
		  rg[[2]]={rt[[-1]],{}};
			rg//.{Node[i1_,{t1_,\[Mu]_List},{a___,Node[i2_,{t2_,\[Mu]T},{m___}],b___}]:>
						(\[Lambda]=mu (t1-t2)/2;
							j=If[\[Lambda]==0,0,Random[PoissonDistribution[\[Lambda]]]];
							nm=nm+j;Node[i1,{t1,\[Mu]},{a,Node[i2,{t2,Sort[Join[\[Mu],Range[nm-j+1,nm]]]},{m}],b}])}]];


(* ::Input::Initialization:: *)
DeletedMutations[g_Node,{T0_,T1_}]:=Module[{tt={},ii,mi},((mi=MutationInterval[g,#1];ii=IntervalIntersection[Interval[{T0,T1}],Interval[mi]];If[!ii===Interval[],If[(Max[mi]-Min[mi]) RandomReal[]<Max[ii]-Min[ii],AppendTo[tt,#1]]])&)/@Mutations[g];tt];


(* ::Input::Initialization:: *)
RandomBottleneckedGenealogy[lv_,{T0_,T1_},\[Theta]_]:=
	Module[{g=RandomGenealogy[lv,MutationRate->\[Theta]] ,dl},
	   dl=DeletedMutations[g,{T0,T1}];
		TransformInformation[g,ReplacePart[#2,Complement[#2[[2]],dl],2]&]];


(* ::Input::Initialization:: *)
MomentGeneratingFunction[Node[i_,_List,{Node[a_,s_List,{nn__Node}]}],\[Omega]_,\[Theta]_]:=
	MomentGeneratingFunction[Node[a,s,{nn}],\[Omega],\[Theta]];


(* ::Input::Initialization:: *)
MomentGeneratingFunction[Node[i_,_List,{Node[a_,_List,{}],Node[b_,_List,{}]}],\[Omega]_,\[Theta]_]:=
	1/(1+\[Theta](1-(\[Omega][a]+\[Omega][b])/2));


(* ::Input::Initialization:: *)
MomentGeneratingFunction[g_Node,\[Omega]_,\[Theta]_]:=Module[{
			leaves=Leaves[g],
		n,\[Lambda],\[Phi]},
		n=Length[leaves];\[Lambda]=n/2 (\[Theta]+n-1);\[Phi]=\[Theta]/(n(\[Theta]+n-1));
			1/(\[Lambda](1-\[Phi](Plus@@(\[Omega]/@leaves))))*(Plus@@((MomentGeneratingFunction[g/.{Node[x_,y_,{Node[#[[1]],_,{}],Node[#[[2]],_,{}]}]:>Node[x,y,{}],Node[x_,y_,{Node[#[[2]],_,{}],Node[#[[1]],_,{}]}]:>Node[x,y,{}]},\[Omega],\[Theta]])&/@SiblingList[g]))];


(* ::Input::Initialization:: *)
MomentGeneratingFunction[{g__List},\[Omega]_,\[Theta]_]:=MomentGeneratingFunction[{g},\[Omega],\[Theta]]=Module[{
		n=Length[{g}],\[Lambda],\[Phi],ng,gl,i,j},
		If[n==1,1,\[Lambda]=n/2 (\[Theta]+n-1);\[Phi]=\[Theta]/(n(\[Theta]+n-1));
    gl=Flatten[Table[Sort[{{g}[[i]],{g}[[j]]}],{i,2,n},{j,i-1}],1];
		1/(\[Lambda](1-\[Phi](Plus@@(\[Omega][Sort[#]]&/@{g})))) Plus@@((ng={g}/.{{x___,#[[1]],y___,#[[2]],z___}:>Sort[{x,Join[#[[1]],#[[2]]],y,z}],{x___,#[[2]],y___,#[[1]],z___}:>Sort[{x,Join[#[[1]],#[[2]]],y,z}]};MomentGeneratingFunction[ng,\[Omega],\[Theta]])&/@gl)]];


(* ::Input::Initialization:: *)
PossibleCoalescenceOrder[Node[i_,_,{Node[a_,_,{}],Node[b_,_,{}]}]]:={Append[Sort[{a,b}],i]};


(* ::Input::Initialization:: *)
PossibleCoalescenceOrder[Node[i_,_,{Node[a_,s_,{nn__Node}]}]]:=Append[#,i]&/@PossibleCoalescenceOrder[Node[a,s,{nn}]];


(* ::Input::Initialization:: *)
PossibleCoalescenceOrder[g_Node]:=
	Module[{sl=SiblingList[g],tl={},lv,j},
		Do[tl=Join[tl,Join[sl[[j]],#]&/@PossibleCoalescenceOrder[g/.{Node[i_,s_,{Node[sl[[j,1]],_,{}],Node[sl[[j,2]],_,{}]}]:>Node[i,s,{}],Node[i_,s_,{Node[sl[[j,2]],_,{}],Node[sl[[j,1]],_,{}]}]:>Node[i,s,{}]}]],{j,Length[sl]}];lv=Sort[Leaves[g]];
		Join[lv,TakeAway[#,lv]]&/@tl];


(* ::Input::Initialization:: *)
RandomCoalescenceOrder[Node[i_,_,{Node[a_,_,{}],Node[b_,_,{}]}]]:=Append[Sort[{a,b}],i];


(* ::Input::Initialization:: *)
RandomCoalescenceOrder[Node[i_,_,{Node[a_,s_,{nn__Node}]}]]:=Append[RandomCoalescenceOrder[Node[a,s,{nn}]],i];


(* ::Input::Initialization:: *)
RandomCoalescenceOrder[g_Node]:=Module[{sl=SiblingList[g],lv,j,tl},j=RandomInteger[{1,Length[sl]}];tl=Join[sl[[j]],RandomCoalescenceOrder[g/. {Node[i_,s_,{Node[sl[[j,1]],_,{}],Node[sl[[j,2]],_,{}]}]:>Node[i,s,{}],Node[i_,s_,{Node[sl[[j,2]],_,{}],Node[sl[[j,1]],_,{}]}]:>Node[i,s,{}]}]];lv=Sort[Leaves[g]];Join[lv,TakeAway[tl,lv]];


(* ::Input::Initialization:: *)
NumberOfPossibleCoalescences[g_Node,nl_]:=Module[{lv=Leaves[g],ng=g,tt={}},
       Scan[(AppendTo[tt,Length[SiblingList[ng]]];
			ng=ng/.Node[#,s_,{___}]:>Node[#,s,{}])&,TakeAway[nl,lv]];tt];


(* ::Input::Initialization:: *)
Unprotect[IncidenceMatrix];


(* ::Input::Initialization:: *)
IncidenceMatrix[g_Node,nl_List] :=Module[{
			leaves=Leaves[g],
			n=NumberOfLineages[g],S={If[FreeQ[g, Node[#,_,{}]],0,1]&/@nl},x,i},
		 Do[PrependTo[S,First[S]];
	         S[[1,i]]=1;x=(Position[nl,#][[1,1]]&/@Descendants[g,nl[[i]]]);
			    S[[1,x[[1]]]]=0;S[[1,x[[2]]]]=0;,{i,n+1,2n-1}];
Transpose[S]];


(* ::Input::Initialization:: *)
Protect[IncidenceMatrix];


(* ::Input::Initialization:: *)
MonteCarloProbability[Node[i_,_,{g_Node}],nl_List,J_List,\[Theta]_,\[Phi]_,ns_Integer] :=
	Module[{ps=Position[nl,i][[1,1]]},
		MonteCarloProbability[g,Delete[nl,ps],Delete[ J,ps],\[Theta],\[Phi],ns]];


(* ::Input::Initialization:: *)
MonteCarloProbability[g_Node,nl_List,J_List,\[Theta]_,\[Theta]1_,ns_Integer] :=Module[{n=NumberOfLineages[g],S=IncidenceMatrix[g,nl],i,j,\[Phi]v,\[Phi]v1,\[Phi],\[Phi]1,\[Lambda],Jt},
		\[Phi]=Table[\[Theta]/(i(\[Theta]+i-1)),{i,1,n}];\[Phi]v=(#.\[Phi]1)&/@S;
		\[Phi]1=Table[\[Theta]1/(i(\[Theta]1+i-1)),{i,1,n}];\[Phi]v1=(#.\[Phi]1)&/@S;
		\[Lambda]=\!\(
\*UnderoverscriptBox[\(\[Product]\), \(i = 2\), \(n\)]\((
\*FractionBox[\(i\), \(2\)]\ \((\[Theta] + i - 1)\))\)\);
 (Times@@MapThread[Power,{\[Phi]v,J}]/(\[Lambda](Times@@(Factorial/@J) )))*Table[
				Jt=Plus@@MapThread[RandomMultinomial[#3,(#1 \[Phi]1)/#2]&,{S,\[Phi]v1,J}];
				Times@@MapThread[(#1! (#2/#3)^#1)&,{Jt,\[Phi],\[Phi]1}],{ns}]];


(* ::Input::Initialization:: *)
MonteCarloProbability[g_Node,J_List,\[Theta]_,\[Theta]1_,ns_Integer] :=
	Module[{nl=RandomCoalescenceOrder[g]},
		MonteCarloProbability[g,nl,J,\[Theta],\[Theta]1,ns]*(Times@@Drop[NumberOfPossibleCoalescences[g,nl],-1])];


(* ::Input::Initialization:: *)
Options[NumberOfMutations]={NodeFunction->(#2[[2]]&)};


(* ::Input::Initialization:: *)
NumberOfMutations[g_Node,i_,opts___Rule]:=
	Module[{a=Ancestors[g,i],	nf=NodeFunction/.{opts}/.Options[NumberOfMutations]},
		If[a==={},
			0,
			Length[
				Complement[
					nf[i,ExtractInformation[g,i]],
					nf[Last[a],ExtractInformation[g,Last[a]]]]]]];


(* ::Input::Initialization:: *)
Options[Mutations]={NodeFunction->(#2[[2]]&)};


(* ::Input::Initialization:: *)
Mutations[g_Node,opts___Rule]:=Module[{nf=NodeFunction/.{opts}/.Options[Mutations]},
		Union[Flatten[CollapseGenealogy[g,NodeFunction->nf][[2]]]]]


(* ::Input::Initialization:: *)
Mutations[g_Node,i_,opts___Rule]:=Module[{nf=NodeFunction/.{opts}/.Options[Mutations],an=Ancestors[g,i]},
		Complement[nf[i,ExtractInformation[g,i]],If[an==={},{},nf[Last[an],ExtractInformation[g,Last[an ]]]]]]


(* ::Input::Initialization:: *)
Options[MutationOrigin]={NodeFunction->(Take[#2,2]&)};


(* ::Input::Initialization:: *)
MutationOrigin[g_Node,k_,opts___Rule] :=Module[{ll,nf=NodeFunction/.{opts}/.Options[MutationOrigin]},
		ll=CollapseGenealogy[g,NodeFunction->(If[MemberQ[nf[#1,#2][[2]],k],{nf[#1,#2][[1]],#1},{-\[Infinity],#1}]&),Nested->False];
		ll=First[Sort[ll,(#1[[1]]>#2[[1]])&]];
		If[ll[[1]]===-\[Infinity],$Failed,ll[[2]]]];


(* ::Input::Initialization:: *)
Options[MutationInterval]={NodeFunction->(Take[#2,2]&)};


(* ::Input::Initialization:: *)
MutationInterval[g_Node,k_,opts___Rule]:=Module[{nn=MutationOrigin[g,k,opts],an,t0,t1,nf=NodeFunction/.{opts}/.Options[MutationInterval]},
	If[nn===$Failed,$Failed,
			t0=nf[nn,ExtractInformation[g,nn]][[1]];
			an=Ancestors[g,nn];
			If[an==={},{t0,\[Infinity]},
			t1=nf[Last[an],ExtractInformation[g,Last[an]]][[1]];
			{t0,t1}]]];


(* ::Input::Initialization:: *)
Options[ExactProbability]={NodeFunction->(#2[[2]]&)};


(* ::Input::Initialization:: *)
ExactProbability[g_Node,\[Theta]_,opts___Rule]:=Module[{\[Omega],mgf,jl,
			nl=Nodes[g],
			nf=NodeFunction/.{opts}/.Options[ExactProbability]},
		mgf=MomentGeneratingFunction[g,\[Omega],\[Theta]];
	  jl=NumberOfMutations[g,#]&/@nl;
	  jl=Reverse/@Sort[Transpose[{jl,\[Omega]/@nl}]];
		Scan[(mgf=D[mgf,#]/#[[2]]!/.#[[1]]->0)&,jl];mgf//Factor];


(* ::Input::Initialization:: *)
ExactProbability[S_List,\[Theta]_]:=Module[{\[Omega],\[Nu],mgf,jl,rl,ll,nl=Length[S],nm=Length[S[[1]]],ff=Reverse[Sort[Tally[Transpose[S]]],2]},ll=List/@Range[nl];mgf=MomentGeneratingFunction[ll,\[Omega],\[Theta]];Factor[If[0==Plus@@Plus@@S,mgf/. \[Omega][_]:>0,jl=ff/. {i_Integer,s_List}:>{i,\[Nu]@@(Extract[ll,#1]&)/@Position[s,1]}/. \[Nu][a__List]:>\[Nu][Flatten[{a}]];jl=Reverse/@Sort[jl];rl=jl/. {{\[Nu][a_],_}:>\[Omega][a]->\[Nu][a]};mgf=mgf/. rl/. \[Omega][_]:>0;Scan[(mgf=\!\(
\*SubscriptBox[\(\[PartialD]\), \(#1\)]mgf\)/#1[[2]]!/. #1[[1]]->0)&,jl];mgf]]];


(* ::Input::Initialization:: *)
Options[GenealogyToMatrix]={NodeFunction->(#2[[2]]&)};


(* ::Input::Initialization:: *)
GenealogyToMatrix[g:Node[_,_List,_List]|{Node[_,_List,_List]...},opts___Rule]:=ListToMatrix[CollapseGenealogy[g,Nested->False,Node->False,NodeFunction->(NodeFunction/.{opts}/.Options[GenealogyToMatrix])],opts];


(* ::Input::Initialization:: *)
Options[MatrixToGenealogy]={Unrooted->False};


(* ::Input::Initialization:: *)
MatrixToGenealogy[S_List,ll_List,ml_List,opts___Rule]:=
If[ValidMatrixQ[S,opts],
If[Unrooted/.{opts}/.Options[MatrixToGenealogy],
MatrixToUnrootedGenealogy[S,ll,ml],
MatrixToRootedGenealogy[S,ll,ml]],
Message[MatrixToGenealogy::invalidMatrix,S];$Failed];


(* ::Input::Initialization:: *)
MatrixToRootedGenealogy[S_List,ll_List,ml_List]:=Module[{nl=Length[S],j,g,rtn,sharedMutations,nodeCount,lS=MatrixToList[S,MutationLabels->ml]},
	sharedMutations=Extract[ml,#]&/@Position[Transpose[S],{(1)..}];
	nodeCount=2;
	g=Node[1,{0,sharedMutations},{Node[ll[[1]],{0,lS[[1]]},{}]}];
	Do[rtn=FindNode[g,lS[[j]],nodeCount];
			  If[rtn===$Failed,
				g=$Failed;Break[],
				If[!(rtn[[1]]===rtn[[2]]),nodeCount+=1];
				 g=AddGenealogy[g,Node[ll[[j]],{0,lS[[j]]},{}],rtn[[1]],rtn[[2]],{0,rtn[[3]]}]],
			{j,2,nl}];
		g];


(* ::Input::Initialization:: *)
MatrixToGenealogy::invalidMatrix="The matrix `1` is not consistent with any genealogy";


(* ::Input::Initialization:: *)
MatrixToGenealogy::multipleSplit="Mutation `1` appears to split the genealogy at several nodes.  The list of possible nodes, and the current genealogy are `2`, `3`";


(* ::Input::Initialization:: *)
MatrixToUnrootedGenealogy[S_List,ll_List,ml_List]:=
Module[{nl,mlist,j,nleaves=Length[S],nmutns=Length[S[[1]]],rs,rs2,vms,nn=1,ms1,ms2,mm},
nl=Append[Node[#,{0,{}},{1}]&/@ll,Node[nn,{0,{}},ll]];
mlist=MatrixToList[S,MutationLabels->ml];
llist=MatrixToList[Transpose[S],MutationLabels->ll];
vms=ml[[#]]&/@Select[Range[nmutns],Length[llist[[#]]]>1&];
nl=AddMutation[1,vms,AddMutation[ll,mlist,nl]];
Do[If[1<Length[llist[[j]]]<nleaves-1,
(*Print["Doing mutation",j];*)
nds=Cases[nl,Node[_,{_,{___,ml[[j]],___}},{_,_,__}]];
(*Print["nds=",nds];*)
rs=nds/.{Node[nd_,_,rs_]:>(rs2=Select[rs,MemberQ[ExtractInformation[nl,#][[2]],ml[[j]]]&];
{nd,rs2,Complement[rs,rs2]})};
(*Print["rs=",rs];*)
rs=Select[rs,(1<Length[#[[2]]]&&1<Length[#[[3]]])&];
(*Print["rs=",rs];*)
If[Length[rs]>1,Message[MatrixToGenealogy::multipleSplit,ml[[j]],rs,nl]];
If[Length[rs]>0,
(rs=First[rs];
(*Print["Split at ",rs];*)
nn+=1;mm=ExtractInformation[nl,rs[[1]]][[2]];
nl=nl/.Node[rs[[1]],_,_]:>(ms1=Union[Flatten[ExtractInformation[nl,#][[2]]&/@rs[[2]]]];
Node[rs[[1]],{0,Intersection[ms1,mm]},Append[rs[[2]],nn]]);
AppendTo[nl,ms2=Union[Flatten[ExtractInformation[nl,#][[2]]&/@rs[[3]]]];
Node[nn,{0,Intersection[ms2,mm]},Append[rs[[3]],rs[[1]]]]];
((nl=nl/.Node[#,x_,y_]:>Node[#,x,y/.rs[[1]]:>nn])&/@rs[[3]]);)]],
{j,Length[ml]}];
nl];


(* ::Input::Initialization:: *)
FindNode[g_Node,leafMutations_List,newNode_]:=
	Module[{nd=g[[1]],oldNd=g[[1]],desc,nodeMutations,descendantMutations,sharedMutations,lsm,ps,rtn={}},
		While[rtn==={},
		  desc=Descendants[g,nd];
       nodeMutations=ExtractInformation[g,nd][[2]];
       descendantMutations=Complement[#,nodeMutations]&/@(ExtractInformation[g,#][[2]]&/@desc);
       sharedMutations=Intersection[#,leafMutations]&/@descendantMutations;
      lsm=Length/@sharedMutations;
      If[Complement[nodeMutations,leafMutations]==={},
	     If[Max[lsm]==0,
	        rtn={nd,nd,nodeMutations},
	        If[Max[lsm]!=Plus@@lsm,
		          If[Max[lsm]==-\[Infinity],
							rtn={nd,newNode,Intersection[leafMutations,nodeMutations]},
							Print["New leaf",leafMutations,"contains mutations from several branches:",lsm];
		         rtn=$Failed],
		         ps=Position[lsm,Max[lsm]][[1,1]];
		        If[Complement[descendantMutations[[ps]],leafMutations]==={},
			          nd=desc[[ps]],
			         rtn={desc[[ps]],newNode,Join[nodeMutations,Intersection[leafMutations,descendantMutations[[ps]]]]}]]],
	Print["New leaf",leafMutations,"does not contain all mutations in node ",nd];
	rtn=$Failed]];
	rtn];


(* ::Input::Initialization:: *)
Options[MatrixToList]={MutationLabels->Automatic};


(* ::Input::Initialization:: *)
MatrixToList[S_List,opts___Rule] :=Module[{i,nl=Length[S],nm=Length[S[[1]]],ml},
			ml=MutationLabels/.{opts}/.Options[MatrixToList];
		  If[ml===Automatic,ml=Range[nm]];
		  Table[Extract[ml,#]&/@Position[S[[i]],1],{i,nl}]];


(* ::Input::Initialization:: *)
Options[ListToMatrix]={MutationLabels->Automatic};


(* ::Input::Initialization:: *)
ListToMatrix[z_List,opts___Rule] :=
	Module[{i,nl=Length[z],zl=Union[Flatten[z]]},
			ml=MutationLabels/.{opts}/.Options[MatrixToList];
		  If[ml===Automatic,ml=zl];
		  Table[If[MemberQ[z[[i]],#],1,0]&/@ml,{i,nl}]];


(* ::Input::Initialization:: *)
GriffithsTavare[{},\[Theta]_]:=GriffithsTavareFailed[{}];


(* ::Input::Initialization:: *)
GriffithsTavare[{g1_List,g2_List},\[Theta]_]:=
	GriffithsTavare[{g1,g2},\[Theta]]=
		Module[{a1=Plus@@(g1(1-g2)),a2=Plus@@(g2(1-g1))},
		Binomial[a1+a2,a1](\[Theta]/(2(1+\[Theta])))^(a1+a2) 1/(1+\[Theta])];


(* ::Input::Initialization:: *)
GriffithsTavare[S_List,\[Theta]_]:=If[OrderedQ[S]&&OrderedQ[Transpose[S]],GriffithsTavare[S,\[Theta]]=Module[{\[Lambda],ps,dt,ff=DeleteCases[Reverse[Sort[Tally[S]],2],{1,_}],n=Length[S],nm=Length[S[[1]]],mutationTerms,coalescenceTerms},ps=Position[Plus@@S,1];mutationTerms=If[Length[ps]==0,0,If[nm==1,GriffithsTavare[S/. {1->0},\[Theta]],dt=Union[(Transpose[Delete[Transpose[S],#1[[1]]]]&)/@ps];Plus@@(GriffithsTavare[#1,\[Theta]]&)/@dt]];coalescenceTerms=If[ff==={},0,ff=Transpose[ff];If[Max[First[ff]]<=1,0,Plus@@MapThread[1/2 (#1 (#1-1)) GriffithsTavare[Delete[S,Position[S,#2][[1,1]]],\[Theta]]&,ff]]];\[Lambda]=1/2 n (\[Theta]+n-1);Factor[((\[Theta] mutationTerms)/2+coalescenceTerms)/\[Lambda]]],GriffithsTavare[Transpose[Sort[Transpose[Sort[S]]]],\[Theta]]];


(* ::Input::Initialization:: *)
MonteCarloGriffithsTavare[S_List,\[Theta]_,\[Phi]_]:=Module[{pr=1,nS=S,n,ps,J,K,nm=Length[S[[1]]]},While[!nS==={{0}},st=Transpose[nS];ust=Union[st];ps=Position[Plus@@Transpose[ust],1];J=Length[ps];ff=DeleteCases[Reverse[Sort[Tally[nS]],2],{1,_}];K=If[ff==={},0,fft=Transpose[ff];If[Max[First[fft]]<=1,0,1/2 fft[[1]].(fft[[1]]-1)]];n=Length[nS];nS=If[RandomReal[]<(J \[Phi])/(J \[Phi]+2 K),If[Length[nS[[1]]]==1,nS/. {1->0},rj=ps[[RandomInteger[{1,J}],1]];Transpose[Delete[st,Position[st,ust[[rj]]][[1,1]]]]],rk=RandomList[1,(fft[[1]] (fft[[1]]-1))/(2 K)];Delete[nS,Position[nS,fft[[2,1]]][[1,1]]]];pr*=(J \[Phi]+2 K)/(n (\[Theta]+n-1))];pr (\[Theta]/\[Phi])^nm];


(* ::Input::Initialization:: *)
MonteCarloGriffithsTavare[S_List,\[Theta]_]:=MonteCarloGriffithsTavare[S,\[Theta],\[Theta]];


(* ::Input::Initialization:: *)
ValidMatrixQ::notTensor="ValidMatrixQ[`1`] should have as an argument a tensor of rank 2, containing 0 or 1";


(* ::Input::Initialization:: *)
Options[ValidMatrixQ]={Unrooted-> False};


(* ::Input::Initialization:: *)
ValidMatrixQ[S:{{(0|1)...}...},opts___Rule]:=Module[{tS},
If[MatrixQ[S],
If[Dimensions[S][[-1]]<2,
True,
tS=Union[Transpose[S]];
If[Unrooted/.{opts}/.Options[ValidMatrixQ],
Max[ValidMatrixQ[0,0][tS]ValidMatrixQ[1,0][tS]ValidMatrixQ[0,1][tS]ValidMatrixQ[1,1][tS]]==0,
Max[ValidMatrixQ[1,0][tS]ValidMatrixQ[0,1][tS]ValidMatrixQ[1,1][tS]]==0]],
Message[ValidMatrixQ::notTensor,S]]];


(* ::Input::Initialization:: *)
ValidMatrixQ[1,1]=Compile[{{tS,_Integer,2}},
1-(Times@@Transpose[1-Outer[Times,tS,tS,1],{3,2,1}])];
ValidMatrixQ[0,1]=Compile[{{tS,_Integer,2}},
1-(Times@@Transpose[1-Outer[Times,1-tS,tS,1],{3,2,1}])];
ValidMatrixQ[1,0]=Compile[{{tS,_Integer,2}},
1-(Times@@Transpose[1-Outer[Times,tS,1-tS,1],{3,2,1}])];
ValidMatrixQ[0,0]=Compile[{{tS,_Integer,2}},
1-(Times@@Transpose[1-Outer[Times,1-tS,1-tS,1],{3,2,1}])];


(* ::Input::Initialization:: *)
SwapStates[s:{(0|1)...},S:{{(0|1)...}...}]:=(s+#(1-2s))&/@S;


(* ::Input::Initialization:: *)
MissingCombination::invalidMatrix="The matrix is not consistent with any genealogy: `1`";


(* ::Input::Initialization:: *)
MissingCombination[S:{{(0|1)...}...}]:=MissingCombination[S]=
Module[{ut,tS=Transpose[S]},
Outer[(ut=Union[Transpose[{##}]];
Switch[Length[ut],
4,Message[MissingCombination::invalidMatrix,S];$Failed,
3,Complement[{{0,0},{0,1},{1,0},{1,1}},ut]//First,
_,{}])&,tS,tS,1]];


(* ::Input::Initialization:: *)
PossibleRootings[x_?((ListQ[#]&&FreeQ[#, Null])&),S:{{(0|1|Null)...}...}]:=x;
PossibleRootings[{a___List,{c___,Null,d___},b___List},S:{{(0|1|Null)...}...}]:=
Module[{i,\[Alpha],\[Beta],nl=Length[S],nm=Length[S[[1]]],
tS=Transpose[S],miss,ut,j=Length[{c}]+1,cd={c,Null,d},t0,t1,t0Q=True,t1Q=True},
miss=Transpose[MissingCombination[S]][[j]];
t0=Table[If[\[Alpha]==j,
0,
Switch[cd[[\[Alpha]]],
Null,Switch[miss[[\[Alpha]]],
{0,0},1,
{1,0},0,
_,Null],
0,If[miss[[\[Alpha]]]=={0,0},t0Q=False];0,
1,If[miss[[\[Alpha]]]=={1,0},t0Q=False];1]],{\[Alpha],nm}];
t1=Table[If[\[Alpha]==j,
1,
Switch[cd[[\[Alpha]]],
Null,Switch[miss[[\[Alpha]]],
{0,1},1,
{1,1},0,
_,Null],
0,If[miss[[\[Alpha]]]=={0,1},t1Q=False];0,
1,If[miss[[\[Alpha]]]=={1,1},t1Q=False];1]],{\[Alpha],nm}];
If[t0Q,If[t1Q,{a,t0,t1,b},{a,t0,b}],If[t1Q,{a,t1,b},{a,b}]]];


(* ::Input::Initialization:: *)
PossibleRootings[S:{{(0|1|Null)...}...}]:=FixedPoint[PossibleRootings[#,S]&,{Array[Null&,{Length[S[[1]]]}]}];


(* ::Input::Initialization:: *)
AddMutation::invalidLists="The lists of nodes `1` and of mutations `2` are not compatible.";


(* ::Input::Initialization:: *)
AddMutation[n_,m_?(Not[ListQ[#]]&),g:(Node[_,_List,{___Node}]|{Node[_,_List,_List]...})]:=
g/.Node[n,{x_,y_List,z___},d_List]:>Node[n,{x,Append[y,m],z},d];AddMutation[n_,m_List,g:(Node[_,_List,{___Node}]|{Node[_,_List,_List]...})]:=
g/.Node[n,{x_,y_List,z___},d_List]:>Node[n,{x,Join[y,m],z},d];


(* ::Input::Initialization:: *)
(*AddMutation[n_List,m_List,g:(Node[_,_List,{___Node}]|{Node[_,_List,_List]...})]:=
If[Length[n]\[Equal]Length[m],
Fold[AddMutation[#2\[LeftDoubleBracket]1\[RightDoubleBracket],#2\[LeftDoubleBracket]2\[RightDoubleBracket],#1]&,g,Transpose[{n,m}]],
Message[AddMutation::invalidLists,n,m]];*)


(* ::Input::Initialization:: *)
Options[CondenseMatrix]={Unrooted->False};


(* ::Input::Initialization:: *)
CondenseMatrix::notMatrix="`1` is not a matrix";


(* ::Input::Initialization:: *)
CondenseMatrix[S:{{(0|1)...}...},opts___Rule]:=If[MatrixQ[S],
Module[{tSR},
If[Unrooted/.{opts}/.Options[CondenseMatrix],
tSR=DeleteCases[Union[Transpose[S]],{0 ...}|{1 ...}|{0 ... ,1,0 ...}|{1 ... ,0,1 ...}];
Transpose[Union[tSR/.{x:{(0|1)...}:>First[Sort[{x,1-x}]]}]],
Transpose[DeleteCases[Union[Transpose[S]],{0 ...}|{1 ...}|{0 ... ,1,0 ...}]]]],
Message[CondenseMatrix::notMatrix,S]];


(* ::Input::Initialization:: *)
AncestralGraphPattern={AncestralLineagePattern...};


(* ::Input::Initialization:: *)
AncestralLineagePattern=AncestralLineage[_,{_,_},_List,_List,{___List}];


(* ::Input::Initialization:: *)
Junctions[AncestralLineage[_,{_,_},_List,j_List,_List]]:=Drop[j,-1];
Junctions[g:AncestralGraphPattern]:=Union[Flatten[Junctions/@g]];


(* ::Input::Initialization:: *)
MapLength::mixedLengths="The map lengths `1` differ among lineages";


(* ::Input::Initialization:: *)
MapLength[AncestralLineage[_,{_,_},_List,j_List,_List]]:=Last[j];
MapLength[g:AncestralGraphPattern]:=
Module[{ml=Union[MapLength/@g]},
If[Length[ml]>1,
Message[MapLength::mixedLengths,ml]];
ml[[1]]];


(* ::Input::Initialization:: *)
TimesOfEvents[g:AncestralGraphPattern]:=Union[Flatten[g/.AncestralLineage[_,{t0_,t1_},_List,_List,_List]:>{t0,t1}]];


(* ::Input::Initialization:: *)
AllEvents::badJunctions="The junctions at the recombination event at t=`1` in graph `2` do not change by 1.";


(* ::Input::Initialization:: *)
AllEvents::badRelationship="The event at t=`1` in graph `2` does not have the right form.";


(* ::Input::Initialization:: *)
AllEvents[g:AncestralGraphPattern]:=AllEvents[g]=Module[{cs,ce,jj},
(cs=Cases[g,AncestralLineage[_,{#,_},_List,_List,_List]];
ce=Cases[g,AncestralLineage[_,{_,#},_List,_List,_List]];
Switch[Length/@{ce,cs},
{0,_}|{_,0}|{2,1},
{#,ce/.ExtractLabel,cs/.ExtractLabel,None},
{1,2},
jj=TakeAway[Join[cs[[1,4]],cs[[2,4]]],ce[[1,4]]];
(*If[!(MatchQ[jj,{x_,x_,1}]||(Sort[{cs\[LeftDoubleBracket]1,3\[RightDoubleBracket],cs\[LeftDoubleBracket]2,3\[RightDoubleBracket]}]===Sort[{{{}},ce\[LeftDoubleBracket]1,3\[RightDoubleBracket]}])),Message[AllEvents::"badJunctions",#1,g]]*)(* too hard to do *)
If[Not[{}===Cases[Transpose[{cs[[2,4]],cs[[2,3]]}],{jj[[1]],_}][[1,2]]],
cs=Reverse[cs]];
{#,ce/.ExtractLabel,cs/.ExtractLabel,jj[[1]]},
_,
Message[AllEvents::badRelationship,#,g];
{#,ce/.ExtractLabel,cs/.ExtractLabel,None}])&/@TimesOfEvents[g]];


(* ::Input::Initialization:: *)
CoalescenceEvents[g:AncestralGraphPattern]:=Cases[AllEvents[g],{_,{_,_},{_},_}];


(* ::Input::Initialization:: *)
RecombinationEvents[g:AncestralGraphPattern]:=RecombinationEvents[g]=Cases[AllEvents[g],{_,{_},{_,_},_}];


(* ::Input::Initialization:: *)
NullRecombinationEvents[g:AncestralGraphPattern]:=NullRecombinationEvents[g]=Cases[AllEvents[g],{_,{_},{_,_},MapLength[g]}];


(* ::Input::Initialization:: *)
LeafEvents[g:AncestralGraphPattern]:=LeafEvents[g]=Cases[AllEvents[g],{_,{},{__},_}];


(* ::Input::Initialization:: *)
RootEvents[g:AncestralGraphPattern]:=RootEvents[g]=Cases[AllEvents[g],{_,{__},{},_}];


(* ::Input::Initialization:: *)
Leaves::multipleLineages="Some leaves share the same label: `1`"; 


(* ::Input::Initialization:: *)
Leaves[g:AncestralGraphPattern]:=
Module[{ss=Flatten[#[[3]]&/@LeafEvents[g]],uss,res},
uss=Union[ss];res=TakeAway[ss,uss]==={};
If[Not[res],Message[Leaves::multipleLineages,g]];
uss];


(* ::Input::Initialization:: *)
LineagesPresent[g:AncestralGraphPattern,t_]:=
Select[g,(#[[2,1]]<=t<#[[2,2]])&]/.ExtractLabel;
LineagesPresent[g:AncestralGraphPattern]:=
g/.ExtractLabel;


(* ::Input::Initialization:: *)
RecombinantLineages::multipleLineages="Some recombinant lineages share the same label: `1`"; 


(* ::Input::Initialization:: *)
RecombinantLineages[g:AncestralGraphPattern]:=
Module[{ss=Flatten[#[[3]]&/@RecombinationEvents[g]],uss,dss},
uss=Union[ss];dss=TakeAway[ss,uss];
If[Not[dss==={}],Message[RecombinantLineages::multipleLineages,g]];
uss];


(* ::Input::Initialization:: *)
CoalescentLineages::multipleLineages="Some coalescent lineages share the same label: `1`"; 


(* ::Input::Initialization:: *)
CoalescentLineages[g:AncestralGraphPattern]:=
Module[{ss=Flatten[#[[3]]&/@CoalescenceEvents[g]],uss,dss},
uss=Union[ss];dss=TakeAway[ss,uss];
If[Not[dss==={}],Message[CoalescentLineages::multipleLineages,g]];
uss];


(* ::Input::Initialization:: *)
RootLineages::multipleLineages="Some root lineages share the same label: `1`"; 


(* ::Input::Initialization:: *)
RootLineages[g:AncestralGraphPattern]:=
Module[{ss=Flatten[(#[[2]])&/@RootEvents[g]],uss,res},
uss=Union[ss];TakeAway[s,uss]==={};
If[Not[res],Message[RootLineages::multipleLineages,g]];
uss];


(* ::Input::Initialization:: *)
NullLineages[g:AncestralGraphPattern]:=NullLineages[g]=Cases[g,AncestralLineage[_,{_,_},{{}},{MapLength[g]},_List]];


(* ::Input::Initialization:: *)
TimespanOfLineage[g:AncestralGraphPattern,l_]:=ExtractLineage[g,l][[2]];


(* ::Input::Initialization:: *)
TimespanOfJunction[ag:AncestralGraphPattern,j_]:=Module[{cc},
cc=Cases[ag,AncestralLineage[_,{_,_},_,{___,j,___},_]];
{First[Sort[cc/.AncestralLineage[_,{t0_,_},_,_,_]:>t0]],Last[Sort[cc/.AncestralLineage[_,{_,t1_},_,_,_]:>t1]]}];


(* ::Input::Initialization:: *)
ExtractLabel={AncestralLineage[l_,{_,_},_List,_List,_List]:>l};


(* ::Input::Initialization:: *)
ExtractInformation[g:AncestralGraphPattern,l_]:=Last[ExtractLineage[g,l]];


(* ::Input::Initialization:: *)
ExtractLineage::notPresent="Lineage `1` is not present in the graph `2`";


(* ::Input::Initialization:: *)
ExtractLineage::multipleLineages="Lineage `1` occurs more than once in the graph `2`";


(* ::Input::Initialization:: *)
ExtractLineage[g:AncestralGraphPattern,l_List]:=Map[ExtractLineage[g,#]&,l,1];


(* ::Input::Initialization:: *)
ExtractLineage[g:AncestralGraphPattern,l_?(Not[ListQ[#]]&)]:=Module[{cs},
cs=Cases[g,AncestralLineage[l,{_,_},_List,_List,_List]];
Switch[Length[cs],
0,Message[ExtractLineage::notPresent,l,g];{},
1,cs[[1]],
_,Message[ExtractLineage::multipleLineages,l,g];cs]];


(* ::Input::Initialization:: *)
ExtractLineagesEndingAtT[g:AncestralGraphPattern,t_]:=Module[{cs},
cs=Cases[g,AncestralLineage[_,{_,t},_List,_List,_List]]/.ExtractLabel];


(* ::Input::Initialization:: *)
ExtractLineagesStartingAtT[g:AncestralGraphPattern,t_]:=Module[{cs},
cs=Cases[g,AncestralLineage[_,{t,_},_List,_List,_List]]/.ExtractLabel];


(* ::Input::Initialization:: *)
ExtractGenealogy::multipleRoots="Some of the leaves `1` have more than one ancestral lineage at map position `3`: `2`";


(* ::Input::Initialization:: *)
ExtractGenealogy[g:AncestralGraphPattern,x_]:=
Module[{ng=g,ds,ll=Leaves[g],rl},
rl=Union[Ancestors[g,#,AncestorList->Roots,MapPosition->x]&/@ll];
If[Length[rl]==1,
ds=Descendants[g,rl[[1]],MapPosition->x,DescendantList->All];
ds=ds//.{a___,{l_?(Not[MemberQ[ll, #]]&),{}},b___}:>{a,b};
ListToGenealogy[ds,
NodeFunction->({First[TimespanOfLineage[g,#]]}&)],
Message[ExtractGenealogy::multipleRoots,ll,rl,x];$Failed]];


(* ::Input::Initialization:: *)
(* This is an old piece of code which is in some ways more efficient*)
(*
ExtractGenealogy[g:AncestralGraphPattern,x_]:=
Module[{ng=g,ds,ll=Leaves[g],rl},
rl=Union[Flatten[Ancestors[g,#,AncestorList\[Rule]Roots]]]&/@ll;
If[And@@(Length[#]\[Equal]1&/@rl),
ds=RecombinationEvents[g]/.{_,_,{aL_,aR_},j_}\[RuleDelayed]If[x<j,aR,aL];
(ng=DeleteCases[ng,AncestralLineage[#,{_,_},_List,_List,_List]])&/@ds;
ng,
Message[ExtractGenealogy::multipleRoots,ll,rl];$Failed]];
*)


(* ::Input::Initialization:: *)
ExtractGenealogy[g:AncestralGraphPattern]:=Module[{js=Junctions[g]},
ExtractGenealogy[g,#]&/@((Prepend[js,0]+Append[js,1])/2)];


(* ::Input::Initialization:: *)
Options[Descendants]=Append[Options[Descendants],MapPosition->None];


(* ::Input::Initialization:: *)
Descendants::multipleLineages="Several events occur at `1`; `2`";


(* ::Input::Initialization:: *)
Descendants[g:AncestralGraphPattern,l_,opts___Rule]:=
Module[{t0,desc,f,dl=DescendantList/.{opts}/.Options[Descendants],mp,cs,re},
Switch[dl,
Next,
mp=MapPosition/.{opts}/.Options[Descendants];
t0=TimespanOfLineage[g,l]//First;
cs=Cases[g,AncestralLineage[_,{_,t0},_List,_List,_List]]/.ExtractLabel;
If[mp===None,
cs,
re=Cases[AllEvents[g],{t0,_,_,_}];
If[Length[re]!=1,Message[Descendants::multipleLineages,t0,g]];
If[re[[1,-1]]===None,
cs,
If[(mp<re[[1,-1]]&&re[[1,3,1]]===l)||(mp>=re[[1,-1]]&&re[[1,3,2]]===l),
cs,{}]]],
All,
First[FixedPoint[Map[AddDescendants[g,#,opts]&,#,{-2}]&, {l}]],
Leaves,
First[{l}//.{{x__?(Not[ListQ[#]]&)}:>((dd=Descendants[g,#,DescendantList->Next,opts];If[dd==={},#,dd])&/@{x})}]]];


(* ::Input::Initialization:: *)
AddDescendants[g:AncestralGraphPattern,{},___Rule]:={};
AddDescendants[g:AncestralGraphPattern,{x__?(Not[ListQ[#]]&)},opts___Rule]:=
{#,Descendants[g,#,DescendantList->Next,opts]}&/@{x};


(* ::Input::Initialization:: *)
Options[Ancestors]={AncestorList->Previous,MapPosition->None};


(* ::Input::Initialization:: *)
Ancestors::multipleLineages="Several events occur at `1`; `2`";


(* ::Input::Initialization:: *)
Ancestors[g:AncestralGraphPattern,l_,opts___Rule]:=
Module[{t0,anc,f,al=AncestorList/.{opts}/.Options[Ancestors],mp,cs,re},
Switch[al,
Previous,
mp=MapPosition/.{opts}/.Options[Ancestors];
t0=TimespanOfLineage[g,l]//Last;
cs=Cases[g,AncestralLineage[_,{t0,_},_List,_List,_List]]/.ExtractLabel;
If[mp===None,
cs,
re=Cases[AllEvents[g],{t0,_,_,_}];
If[Length[re]!=1,Message[Ancestors::multipleLineages,t0,g]];
If[re[[1,-1]]===None,
cs,
If[mp<re[[1,-1]],{re[[1,3,1]]},{re[[1,3,2]]}]]],
All,
First[FixedPoint[Map[AddAncestors[g,#,opts]&,#,{-2}]&, {l}]],
Roots,
First[{l}//.{{x__?(Not[ListQ[#]]&)}:>(y=Union[Flatten[((dd=Ancestors[g,#,AncestorList->Previous,opts];If[dd==={},#,dd])&/@{x})]];(*Print[y];*)y)}]]];


(* ::Input::Initialization:: *)
AddAncestors[g:AncestralGraphPattern,{},___Rule]:={};
AddAncestors[g:AncestralGraphPattern,{x__?(Not[ListQ[#]]&)},opts___Rule]:=
{#,Ancestors[g,#,AncestorList->Previous,opts]}&/@{x};


(* ::Input::Initialization:: *)
Options[CoalesceLineages]={InformationFunction->(Transpose[{##}]&)};


(* ::Input::Initialization:: *)
CoalesceLineages::badInfoLists="The information lists associated with the two lineages have different lengths.";


(* ::Input::Initialization:: *)
CoalesceLineages[
AncestralLineage[_,{_,_},s1_List,j1_List,i1:{___List}],AncestralLineage[_,{_,_},s2_List,j2_List,i2:{___List}],l12_,t12_,opts___Rule]:=
Module[{if=InformationFunction/.{opts}/.Options[CoalesceLineages],jsl},
If[Length[i1]!=Length[i2],
Message[CoalesceLineages::badInfoLists,i1,i2];$Failed,
jsl=Transpose[Sort[Join[Replace[Transpose[{j1,s1}],{j_,s_}->{j,s,Null},1],Replace[Transpose[{j2,s2}],{j_,s_}->{j,Null,s},1]]]];
jsl=Drop[Transpose[jsl//.{a___,Null,x_?(Not[#===Null]&),b___}->{a,x,x,b}],-1];
jsl=Replace[jsl,{j_,ss1_,ss2_}->{j,Union[Join[ss1,ss2]]},1];
jsl=jsl//.{a___,{j_?(Not[ListQ[#]]&),s__},{j_?(Not[ListQ[#]]&),__},b___}->{a,{j,s},b};
jsl=jsl//.{a___,{_?(Not[ListQ[#]]&),s__},{jj2_?(Not[ListQ[#]]&),s__},b___}->{a,{jj2,s},b};
jsl=Transpose[jsl];
AncestralLineage[l12,{t12,\[Infinity]},Sort/@jsl[[2]],jsl[[1]],if[i1,i2]]]];


(* ::Input::Initialization:: *)
Options[RecombineLineage]={InformationFunction->{Identity,Identity}};


(* ::Input::Initialization:: *)
RecombineLineage[AncestralLineage[_,{_,_},s_List,j_List,i_List],{lL_,lR_},x_,t_,opts___Rule]:=
Module[{if=InformationFunction/.{opts}/.Options[RecombineLineage],jsl,jsL,jsR,jsRR},
jsl=Transpose[{j,s}];
jsRR=Select[jsl,(#[[1]]>x)&];
If[jsRR[[1,2]]==={},
jsR=Transpose[jsRR];
jsL=Transpose[Join[Select[jsl,(#[[1]]<=x)&],{{jsR[[1,-1]],{}}}]],
jsR=Transpose[Prepend[jsRR,{x,{}}]];
jsL=Transpose[Join[Select[jsl,(#[[1]]<=x)&],{{x,jsR[[2,2]]},{jsR[[1,-1]],{}}}]]];
{AncestralLineage[lL,{t,\[Infinity]},Sort/@jsL[[2]],jsL[[1]],if[[1]][i]],
AncestralLineage[lR,{t,\[Infinity]},Sort/@jsR[[2]],jsR[[1]],if[[2]][i]]}];


(* ::Input::Initialization:: *)
Options[AddRecombinantLineages]={DeleteNullLineages->False};


(* ::Input::Initialization:: *)
AddRecombinantLineages[g:AncestralGraphPattern,l_,{lL_,lR_},x_,t_,opts___Rule]:=
Module[{rl=RecombineLineage[ExtractLineage[g,l],{lL,lR},x,t]},
If[(DeleteNullLineages/.{opts}/.Options[AddRecombinantLineages])&&(rl[[1,3]]==={{}}||rl[[2,3]]==={{}}),
g,
Join[g/.AncestralLineage[l,{t0_,_},s_,j_,i_]:>AncestralLineage[l,{t0,t},s,j,i],rl]]];


(* ::Input::Initialization:: *)
AddCoalescentLineage[g:AncestralGraphPattern,{l1_,l2_},lC_,t_]:=Module[{cl=CoalesceLineages[ExtractLineage[g,l1],ExtractLineage[g,l2],lC,t]},Append[g/.AncestralLineage[ll:l1|l2,{t0_,_},s_,j_,i_]:>AncestralLineage[ll,{t0,t},s,j,i],cl]];


(* ::Input::Initialization:: *)
RandomCoalescenceTimes[k_Integer,R_]:=Module[{t,\[Lambda]=1/2 k (k-1)+k R},t=Random[ExponentialDistribution[\[Lambda]]];If[RandomReal[]<(k R)/\[Lambda],{t,k+1,Random[UniformDistribution[0,R]]},{t,k-1,None}]];


(* ::Input::Initialization:: *)
RandomCoalescenceTimes[n_Integer,k_Integer,R_]:=Drop[FoldList[#2+{#1[[1]],0,0}&,{0,0,0},
Drop[NestList[RandomCoalescenceTimes[#[[2]],R]&,{0,k,0},n],1]],1];


(* ::Input::Initialization:: *)
Options[RandomGenealogy]=Join[Options[RandomGenealogy],{PrintDetails->False,MaxTime->\[Infinity],Fixation->False}];


(* ::Input::Initialization:: *)
RandomGenealogy::badRec="Attempt to add recombinant lineages derived from `1` to `2` failed.";
RandomGenealogy::oneRec="Only one recombinant lineages derived from `1` added to `2`: error.";


(* ::Input::Initialization:: *)
RandomGenealogy[ll_List,n_Integer,R_,opts___Rule]:=
Module[{rct,g1=g0=AncestralLineage[#,{0,\[Infinity]},{{#}},{R},{}]&/@ll,k=0,lvs=ll,nl,t=0,cl,
pd=PrintDetails/.{opts}/.Options[RandomGenealogy],
tm=MaxTime/.{opts}/.Options[RandomGenealogy],
fix=Fixation/.{opts}/.Options[RandomGenealogy]},
While[k<=n\[And]t<tm\[And]If[fix,
Not[FixedQ[ExtractLineage[g0,#]&/@lvs,ll]],
True],
(k+=1;
rct=RandomCoalescenceTimes[Length[lvs],R];t+=rct[[1]];
If[pd,Print[rct]];
If[Last[rct]===None,
nl=RandomSample[lvs,2];
If[pd,Print["Coalescing ",nl,"; current lineages ",lvs]];
g1=AddCoalescentLineage[g0,nl,k+1,t];
lvs=TakeAway[lvs,nl];lvs=Append[lvs,k+1];k+=1,
nl=RandomSample[lvs,1][[1]];
If[pd,Print["Recombining ",nl,"; current lineages ",lvs]];
g1=AddRecombinantLineages[g0,nl,{k+1,k+2},rct[[3]],t,opts];
(*If[pd,Print[g0,Tab,g1]];*)
Switch[Length[g1]-Length[g0],
0,Null,
1,Message[RandomGenealogy::oneRec,nl,g1];
lvs=TakeAway[lvs,{nl}];lvs=Join[lvs,{k+1}];k+=1,
2,
lvs=TakeAway[lvs,{nl}];lvs=Join[lvs,{k+1,k+2}];k+=2,
_,Message[RandomGenealogy::badRec,nl,g1]]];
If[pd,
cl=ExtractLineage[g1,#]&/@lvs;
Print["Current lineages =",cl," fixed? ",FixedQ[cl,ll]]];g0=g1)];
g1];


(* ::Input::Initialization:: *)
RandomGenealogy[ll_List,rct:{{_,_Integer,_}...},R_,opts___Rule]:=
Module[{g1,g0=AncestralLineage[#,{0,\[Infinity]},{{#}},{R},{}]&/@ll,k=0,lvs=ll,nl,pd=PrintDetails/.{opts}/.Options[RandomGenealogy]},
(If[pd,Print[#]];
If[Last[#]===None,
nl=RandomSample[lvs,2];
If[pd,Print["Coalescing ",nl,"; current lineages ",lvs]];
g1=AddCoalescentLineage[g0,nl,k+1,#[[1]]];
lvs=TakeAway[lvs,nl];lvs=Append[lvs,k+1];k+=1,
nl=RandomSample[lvs,1][[1]];
If[pd,Print["Recombining ",nl,"; current lineages ",lvs]];
g1=AddRecombinantLineages[g0,nl,{k+1,k+2},#[[3]],#[[1]]];
Switch[Length[g1]-Length[g0],
1,lvs=TakeAway[lvs,{nl}];lvs=Join[lvs,{k+1}];k+=1,
2,lvs=TakeAway[lvs,{nl}];lvs=Join[lvs,{k+1,k+2}];k+=2,
_,Message[RandomGenealogy::badRec,nl,g1]]];
If[pd,Print["G=",g1]];g0=g1)&/@rct;
g1];


(* ::Input::Initialization:: *)
Segments[al:AncestralLineagePattern,l_]:=Module[{xx=al/.AncestralLineage[_,{_,_},s_,j_,_]:>{s,j},yy},
yy=Replace[Transpose[xx],{{___?(FreeQ[#,l]&)}:>{},{___?(FreeQ[#,l]&),l,___?(FreeQ[#,l]&)}:>{l}},{2}]//.{a___,{s_List,x0_},{s_List,x1_},b___}:>{a,{s,x1},b};
yy=(yy//.
{{b___,{{},x0_},
{{___,l,___},x1_},c___}:>{b,{x0,x1},c},
{b___,{{},_}}:>{b},
{{{___,l,___},x0_},b___}:>{{0,x0},b}})];


(* ::Input::Initialization:: *)
Segments[al:AncestralGraphPattern,l_]:=Segments[#,l]&/@al;


(* ::Input::Initialization:: *)
Options[PlotSegments]={JunctionStyle->{Black},SegmentStyle->{Blue},BackgroundStyle->{Yellow}};


(* ::Input::Initialization:: *)
PlotSegments[al:AncestralLineagePattern,l_,y_,opts___Rule]:=
Module[{segs=Segments[al,l],yy,
bs=BackgroundStyle/.{opts}/.Options[PlotSegments],
ss=SegmentStyle/.{opts}/.Options[PlotSegments]},
yy=Join[bs,{Line[{{0,y},{MapLength[al],y}}]},ss,
{Replace[segs,{x0_,x1_}:>Line[{{x0,y},{x1,y}}],1]}];
Graphics[yy]];


(* ::Input::Initialization:: *)
PlotSegments[al:AncestralGraphPattern,l_,{y0_,y1_},opts___Rule]:=
Module[{segs=Segments[al,l],yy,
jj=Junctions[al],y,k,nl=Length[al],
bs=BackgroundStyle/.{opts}/.Options[PlotSegments],
js=JunctionStyle/.{opts}/.Options[PlotSegments],
ss=SegmentStyle/.{opts}/.Options[PlotSegments]},
yy=Join[js,Replace[jj,x_:>Line[{{x,y0},{x,y1}}],1],bs,Table[Line[{{0,y},{MapLength[al],y}}],{y,y0,y1,(y1-y0)/Max[1,nl-1]}],Table[Join[ss,Replace[segs[[k]],{x0_,x1_}:>{Line[{{x0,(y0(nl-k)+y1(k-1))/Max[1,nl-1]},{x1,(y0(nl-k)+y1(k-1))/Max[1,nl-1]}}]},1]],{k,nl}]];
Graphics[yy]];


(* ::Input::Initialization:: *)
FixedQ[AncestralLineage[_,_List,s_List,_List,_List],lvs_List]:=(Complement[Sort/@s,{{},Sort[lvs]}]==={});
FixedQ[ag:AncestralGraphPattern,lvs_List]:=And@@(FixedQ[#,lvs]&/@ag);


(* ::Input::Initialization:: *)
MRCA[g_Node,{}]:={};
MRCA[g_Node,{(x_)..}]:=x;
MRCA[g_Node,nl_List]:=Module[{al=Ancestors[g,#]&/@nl},
Last[TakeAway[First[al],Complement[First[al],Intersection@@al]]]];


(* ::Input::Initialization:: *)
PairwiseDivergence[g_Node,nl_List]:=First[ExtractInformation[g,MRCA[g,nl]]];
PairwiseDivergence[g_Node]:=PairwiseDivergence[g,#]&/@Union[Sort/@DeleteCases[Flatten[Outer[List,Leaves[g],Leaves[g]],1],{a_,a_}]];


(* ::Input::Initialization:: *)
PairwiseDifference[g_Node,nl_List]:=Module[{ml=ExtractInformation[g,#][[2]]&/@nl},
Complement[Union@@ml,Intersection@@ml]];
PairwiseDifference[g_Node]:=Length[PairwiseDifference[g,#]]&/@Union[Sort/@DeleteCases[Flatten[Outer[List,Leaves[g],Leaves[g]],1],{a_,a_}]];


(* ::Input::Initialization:: *)
MeanPairwiseDivergence[g_Node]:=Mean[PairwiseDivergence[g]];


(* ::Input::Initialization:: *)
ExtractCoalescenceTimes[g_Node]:=Union[First/@ExtractInformation[g]];


(* ::Input::Initialization:: *)
LengthOfGenealogy[g_Node]:=Module[{ct=ExtractCoalescenceTimes[g]},
Last[ct]+Plus@@ct];


(* ::Input::Initialization:: *)
DepthOfGenealogy[g_Node]:=Last[ExtractCoalescenceTimes[g]];


(* ::Input::Initialization:: *)
PairwiseDivergencePlot[gl:{__Node},{dm_,d_},opts___Rule]:=
Module[{bc=Plus@@(BinCounts[PairwiseDivergence[#],{0,dm,d}]&/@gl)},
ListPlot[Transpose[{Range[d/2,dm-d/2,d],bc}],opts]];
PairwiseDivergencePlot[g_Node,{dm_,d_},opts___Rule]:=
PairwiseDivergencePlot[{g},{dm,d},opts];


(* ::Input::Initialization:: *)
PairwiseDifferencePlot[gl:{__Node},{dm_,d_},opts___Rule]:=
Module[{bc=Plus@@(BinCounts[PairwiseDifference[#],{0,dm,d}]&/@gl)},
ListPlot[Transpose[{Range[d/2,dm-d/2,d],bc}],opts]];
PairwiseDifferencePlot[g_Node,{dm_,d_},opts___Rule]:=
PairwiseDifferencePlot[{g},{dm,d},opts];


(* ::Input::Initialization:: *)
DeleteNullLineages[g:AncestralGraphPattern]:=DeleteCases[g,AncestralLineage[_,{_,_},{{}},{_},_List]];


(* ::Input::Initialization:: *)
BlockSizes[AncestralLineage[_,{_,_},{{}},_List,_List]]:=0;
BlockSizes[AncestralLineage[_,{_,_},_List,r_List,_List]]:=r-Prepend[Drop[r,-1],0];
BlockSizes[g:AncestralGraphPattern]:=BlockSizes/@g;
